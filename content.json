{"meta":{"title":"qiubyte","subtitle":"技术菜鸟!","description":null,"author":"qiubyte","url":"https://qiubyte.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-12-30T02:12:00.715Z","updated":"2022-12-30T02:12:00.715Z","comments":false,"path":"/404.html","permalink":"https://qiubyte.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2022-12-30T02:12:00.719Z","updated":"2022-12-30T02:12:00.719Z","comments":false,"path":"about/index.html","permalink":"https://qiubyte.github.io/about/index.html","excerpt":"","text":"不定期更新，谢谢支持！ 12古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事要躬行。"},{"title":"书单","date":"2022-12-30T02:12:00.720Z","updated":"2022-12-30T02:12:00.720Z","comments":false,"path":"books/index.html","permalink":"https://qiubyte.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-30T02:12:00.720Z","updated":"2022-12-30T02:12:00.720Z","comments":false,"path":"categories/index.html","permalink":"https://qiubyte.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-12-30T02:12:00.720Z","updated":"2022-12-30T02:12:00.720Z","comments":true,"path":"links/index.html","permalink":"https://qiubyte.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-12-30T02:12:00.721Z","updated":"2022-12-30T02:12:00.721Z","comments":false,"path":"repository/index.html","permalink":"https://qiubyte.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-30T02:12:00.721Z","updated":"2022-12-30T02:12:00.721Z","comments":false,"path":"tags/index.html","permalink":"https://qiubyte.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"maven多模块项目指定module打包","slug":"2022/maven多模块项目指定module打包","date":"2022-12-07T13:45:00.000Z","updated":"2022-12-30T02:51:55.427Z","comments":true,"path":"2022/12/07/2022/maven多模块项目指定module打包/","link":"","permalink":"https://qiubyte.github.io/2022/12/07/2022/maven多模块项目指定module打包/","excerpt":"maven项目由多个module，只想打指定的module如何执行命令?","text":"maven项目由多个module，只想打指定的module如何执行命令? 指定module打包项目结构如下12345678multi-parent ├── multi-config -- 配置中心├── multi-web -- web目录├── multi-model -- model├── multi-facade -- 门面封装├── multi-core -- 核心业务├── multi-dao -- 数据层└── multi-util -- 工具 直接进入到项目的根目录下 使用maven打包，相关命令示例12345-- 只打webmvn clean package -pl multi-web -Dmaven.test.skip=true-- 打web和web依赖module的包mvn clean package -pl multi-web -am -Dmaven.test.skip=true 使用命令说明 1234567clean： 清空生成的文件package：生成target目录，编译、测试代码，生成测试报告，生成jar/war文件-pl： 打包指定模块，以逗号分隔-am： 打包所指定模块的依赖模块的依赖，含有传递依赖-P： 指定环境-rf： 按指定顺序开始打包-Dmaven.test.skip ：跳过测试，不然所有测试类都要执行而且必须要正确通过","categories":[{"name":"maven","slug":"maven","permalink":"https://qiubyte.github.io/categories/maven/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://qiubyte.github.io/tags/tools/"}]},{"title":"SpringBoot不使用配置中心实现本地配置文件定时动态刷新","slug":"2021/SpringBoot不使用配置中心实现本地配置文件定时动态刷新","date":"2021-08-04T12:05:00.000Z","updated":"2022-12-30T02:12:00.719Z","comments":true,"path":"2021/08/04/2021/SpringBoot不使用配置中心实现本地配置文件定时动态刷新/","link":"","permalink":"https://qiubyte.github.io/2021/08/04/2021/SpringBoot不使用配置中心实现本地配置文件定时动态刷新/","excerpt":"由于还没有接入nacos配置中心，所以需要出一个版本更新本地动态刷新配置的功能，实现配置的动态更新。经过研究发现SpringCloud已经提供了手动接口/actuator/refresh方式刷新的功能，这里再进行处理下实现定时任务动态刷新配置。","text":"由于还没有接入nacos配置中心，所以需要出一个版本更新本地动态刷新配置的功能，实现配置的动态更新。经过研究发现SpringCloud已经提供了手动接口/actuator/refresh方式刷新的功能，这里再进行处理下实现定时任务动态刷新配置。 使用版本SpringBoot版本2.3.10.RELEASE 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 首先集成SpringCloud中的refresh刷新功能上面已经添加了所有的依赖包。依赖spring-cloud-starter-config来实现配置更新，所以必须要有 yml配置application.yml配置文件添加配置test.version, 必须要添加endpoints refresh对外暴露接口 12345678910111213server: port: 8011 undertow: threads: io: 10 worker: 40management: endpoints: web: exposure: include: health,info,prometheus,refreshtest: version: 1.0.0 @RefreshScope注解在配置获取参数的地方加上@RefreshScope注解，必须要加这个注解才能够实现配置刷新。(@Data是Lombok注解) 12345678@Data@RefreshScope@Component(&quot;propertyConfig&quot;)public class PropertyConfig &#123; @Value(&quot;$&#123;test.version:false&#125;&quot;) private String testVersion;&#125; 添加controller123456789101112@Slf4j@RestControllerpublic class VersionController &#123; @Resource private PropertyConfig propertyConfig; @RequestMapping(value = &#123;&quot;/test/version&quot;&#125;, method = RequestMethod.GET) public String testVersion() &#123; return propertyConfig.getTestVersion(); &#125;&#125; 刷新步骤和现象1234567891011121314151. 浏览器或着postman调用 http://localhost:8011/test/version接口。返回结果：1.0.02. application.yml配置文件修改test: version: 2.0.03. post方式 调用 http://localhost:8011/actuator/refresh， 注意这里一定是post。请求会返回已经被刷新的配置key列表：[ &quot;test.version&quot;] 4. 重复1的逻辑，调用 http://localhost:8011/test/version接口。返回结果：2.0.0 注意问题 http://localhost:8011/actuator/refresh 接口必须要用post方式调用。 比如在idea中运行，修改的配置文件一定是编译目录下的yml配置文件，一般在idea中是橘黄色标识 target/classes下的application.yml 分析refresh的实现找到/actuator/refresh接口的实现类12345678910111213141516@Endpoint(id = &quot;refresh&quot;)public class RefreshEndpoint &#123; private ContextRefresher contextRefresher; public RefreshEndpoint(ContextRefresher contextRefresher) &#123; this.contextRefresher = contextRefresher; &#125; @WriteOperation public Collection&lt;String&gt; refresh() &#123; Set&lt;String&gt; keys = this.contextRefresher.refresh(); return keys; &#125;&#125; 发现就是使用 contextRefresher.refresh() 方法实现刷新的。所以我们可以利用这个方法来自己控制什么时候动态刷新配置。 感兴趣可以深入看一下源码内部实现。 集成schedule任务定时刷新开启scheduleApplication上加上@EnableScheduling注解 12345@EnableScheduling@SpringBootApplicationpublic class Application &#123; // ......&#125; 定时刷新配置任务代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.actuate.endpoint.annotation.WriteOperation;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.cloud.context.refresh.ContextRefresher;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.io.File;import java.util.Set;@RefreshScope@Componentpublic class PropertiesRefreshTask &#123; private static final Logger log = LoggerFactory.getLogger(PropertiesRefreshTask.class); /** * 文件更新时间 */ private long fileUpdateTime = 0L; /** * 这里是配置文件的目录 */ @Value(&quot;$&#123;yml.path:/usr/local/lark&#125;&quot;) private String ymlPath; @Resource private ContextRefresher contextRefresher; /** * 30s检查一次 */ @WriteOperation @Scheduled(fixedDelay = 30000L) public void propertiesRefreshTask() &#123; try &#123; File file = new File(ymlPath + &quot;/application.yml&quot;); // 检测文件是否存在 if (!file.exists()) &#123; log.warn(&quot;application.yml not exist&quot;); return; &#125; long lastModifiedTime = file.lastModified(); // 文件更新时间和记录对比 if (fileUpdateTime == 0 || fileUpdateTime &gt;= lastModifiedTime) &#123; fileUpdateTime = lastModifiedTime; return; &#125; Set&lt;String&gt; keys = contextRefresher.refresh(); log.info(&quot;propertiesRefresh keys=&#123;&#125;&quot;, keys); &#125; catch (Exception e) &#123; log.error(&quot;propertiesRefresh exception=&#123;&#125;&quot;, e.getMessage(), e); &#125; &#125;&#125; 刷新步骤和现象12345678910111. 浏览器或着postman调用 http://localhost:8011/test/version接口返回结果：1.0.02. application.yml配置文件修改test: version: 2.0.03. 等待30s时间 4. 重复1的逻辑，调用 http://localhost:8011/test/version接口返回结果：2.0.0 总结 这个是没有接入配置中心导致这么使用的原因，还是建议使用配置中心来实现配置动态加载。 后续会从源码角度分析下SrpingCloud的refresh的实现逻辑及作用范围。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://qiubyte.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://qiubyte.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot 给Controller RequestMapping添加统一路径前缀","slug":"2021/SpringBoot 给Controller RequestMapping添加统一路径前缀","date":"2021-08-03T13:05:00.000Z","updated":"2022-12-30T02:12:00.719Z","comments":true,"path":"2021/08/03/2021/SpringBoot 给Controller RequestMapping添加统一路径前缀/","link":"","permalink":"https://qiubyte.github.io/2021/08/03/2021/SpringBoot 给Controller RequestMapping添加统一路径前缀/","excerpt":"工作中SpringMVC切换成SpringBoot项目遇到另一个问题，因为之前tomcat部署时候webapps下的目录名也是作为路径的，而springboot之后不需要整个路径名称，所以需要兼容老接口加统一的前缀。","text":"工作中SpringMVC切换成SpringBoot项目遇到另一个问题，因为之前tomcat部署时候webapps下的目录名也是作为路径的，而springboot之后不需要整个路径名称，所以需要兼容老接口加统一的前缀。 首先对使用的springboot版本进行一个描述springboot版本2.3.10.RELEASE 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 方法1(针对Controller部分替换) 因为只需要对部分老接口添加前缀，所以加了一个注解来实现。 123456789101112131415161718192021222324252627282930313233343536373839import org.springframework.core.annotation.AliasFor;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 老的 controller层统一使用该注解 * */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@RestController@RequestMappingpublic @interface OldRestController &#123; /** * Alias for &#123;@link RequestMapping#name&#125;. */ @AliasFor(annotation = RequestMapping.class) String name() default &quot;&quot;; /** * Alias for &#123;@link RequestMapping#value&#125;. */ @AliasFor(annotation = RequestMapping.class) String[] value() default &#123;&#125;; /** * Alias for &#123;@link RequestMapping#path&#125;. */ @AliasFor(annotation = RequestMapping.class) String[] path() default &#123;&#125;;&#125; 将@OldRestController注解替换以前的@RestController注解。 1234@OldRestControllerpublic class AddressController extends BaseController &#123; // ...... code....&#125; 写一个配置类，针对@OldRestController注解的累全部添加前缀。 123456789101112131415import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 统一添加请求uri前缀 */@Configurationpublic class PathConfig implements WebMvcConfigurer &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; configurer .addPathPrefix(&quot;/v1/api&quot;, c -&gt; c.isAnnotationPresent(OldRestController.class)); &#125;&#125; 测试一下老接口完全兼容没有问题。 方法2(全局添加) 这里其实是对整个项目访问添加前缀，对于静态资源也会加上此前缀。123server: servlet: context-path: /v1/api 总结 由于此项目中只兼容老的接口，新接口有特定的规则，所以采用了方法1。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://qiubyte.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://qiubyte.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot Undertow监听多个端口","slug":"2021/SpringBoot Undertow监听多个端口","date":"2021-08-03T12:05:00.000Z","updated":"2022-12-30T02:12:00.719Z","comments":true,"path":"2021/08/03/2021/SpringBoot Undertow监听多个端口/","link":"","permalink":"https://qiubyte.github.io/2021/08/03/2021/SpringBoot Undertow监听多个端口/","excerpt":"工作中SpringMVC切换成SpringBoot项目遇到一个问题，需要监听新的端口8011并且需要对老8080端口兼容，所以也需要对8080端口监听。搜了下网上主要都是tomcat启用多个监听，Undertow的基本没有，而实际我们使用的就是Undertow，所以研究了一下，在这里记录一下的。","text":"工作中SpringMVC切换成SpringBoot项目遇到一个问题，需要监听新的端口8011并且需要对老8080端口兼容，所以也需要对8080端口监听。搜了下网上主要都是tomcat启用多个监听，Undertow的基本没有，而实际我们使用的就是Undertow，所以研究了一下，在这里记录一下的。 监听多个端口步骤首先对使用的springboot版本进行一个描述springboot版本2.3.10.RELEASE 1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;!-- 剔除tomcat包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 使用undertow --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置 server.port=8011是必须要监听的端口 server.additional-ports=8080是额外需要监听的一系列端口，可以配置多个，以逗号分隔123server: port: 8011 additional-ports: 8080 具体配置代码将UndertowBuilderCustomizer添加到UndertowServletWebServerFactory，然后使用Builder添加一个listener 12345678910111213141516171819202122232425262728293031import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory;import org.springframework.boot.web.servlet.server.ServletWebServerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class WebServerConfiguration &#123; /** * 额外端口监听 */ @Value(&quot;$&#123;server.additional-ports:&#125;&quot;) private String additionalPorts; @Bean public ServletWebServerFactory undertowFactory() &#123; UndertowServletWebServerFactory undertowFactory = new UndertowServletWebServerFactory(); undertowFactory.addBuilderCustomizers(builder -&gt; &#123; if (StringUtils.isBlank(additionalPorts)) &#123; return; &#125; String[] ports = additionalPorts.split(&quot;,&quot;); for (String port : ports) &#123; builder.addHttpListener(Integer.parseInt(StringUtils.trim(port)), &quot;0.0.0.0&quot;); &#125; &#125;); return undertowFactory; &#125;&#125; 后续可以通过netstat命令查看到进程已经监听了两个端口了。 总结 网上搜了比较多的笔记，基本都是复制粘贴的没有什么帮助。搜不到不如自己研究下，对整个流程加载也会更了解。 虽然自己研究也实现了，但也浪费了一些时间。所以第一步应该想到SpringBoot官方参考指南上查找相关的用法，果然后面在官方参考文档中找到了(详见参考资料2)。 参考资料 官网 https://undertow.io/ Spring Boot Reference Guide - Enable Multiple Listeners with Undertow https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#howto-enable-multiple-listeners-in-undertow","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://qiubyte.github.io/categories/SpringBoot/"}],"tags":[{"name":"Undertow","slug":"Undertow","permalink":"https://qiubyte.github.io/tags/Undertow/"}]},{"title":"Win10 Synaptics触摸板双指无法模拟右键等问题处理","slug":"2021/Win10使用Synaptics触摸板一些问题处理","date":"2021-06-26T11:32:00.000Z","updated":"2022-12-30T02:51:10.918Z","comments":true,"path":"2021/06/26/2021/Win10使用Synaptics触摸板一些问题处理/","link":"","permalink":"https://qiubyte.github.io/2021/06/26/2021/Win10使用Synaptics触摸板一些问题处理/","excerpt":"总结一些重新安装系统之后出现的一些触摸板多指失灵的一些处理方法。主要针对Synaptics驱动触摸板，其他驱动触摸板没有了解，可以尝试不确定是否有效。","text":"总结一些重新安装系统之后出现的一些触摸板多指失灵的一些处理方法。主要针对Synaptics驱动触摸板，其他驱动触摸板没有了解，可以尝试不确定是否有效。 触摸板问题和处理方法Synaptics触摸板无法实现双指单击模拟鼠标右键点击触摸板双指单击触摸板是可以模拟鼠标右键的，相当于可以打开菜单，如果双指单击触摸板后没有反应，可以参考如下方法处理： 12341、打开注册表（快捷键Win+R，输入&quot;regedit&quot;回车即可打开注册表）。2、直接找到路径&quot;计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Synaptics\\SynTP\\TouchPadSMB2cTM2334-1&quot;（注意，因为硬件及软件版本的不同，这里具体的名称可能不太一样，不过前面应该都是”TouchPadSMB”)。3、将其中”2FingerTapAction”项的值改为2。4、先试一下效果，如果没有效果的话尝试重新启动下电脑。 触摸板四指手势切换虚拟桌面方向反的win10触摸板四指手势可以切换虚拟桌面，如果发现左右滑动时窗口切换方向和滑动方向相反可以尝试修改注册表信息解决下，方法如下： 12341、打开注册表（快捷键Win+R，输入&quot;regedit&quot;回车即可打开注册表）。2、找到路径 &quot;计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Synaptics\\SynTPEnh\\ZoneConfig\\Win10\\4FHorizontal Scrolling&quot;3、双击修改，就是交换&quot;NegativeCustomZoneID&quot; 和 &quot;PositiveCustomZoneID&quot;的数值数据。（例如:原始NegativeCustomZoneID数值是88，PositiveCustomZoneID数值是87，修改后NegativeCustomZoneID数值是87，PositiveCustomZoneID数值是88。这里数值要按照电脑中实际的数据交换）4、一般直接可以生效，如果效果没有改变的话尝试重新启动下电脑。","categories":[{"name":"tools","slug":"tools","permalink":"https://qiubyte.github.io/categories/tools/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://qiubyte.github.io/tags/Windows/"}]},{"title":"MySQL blob导出sql文件乱码","slug":"2020/20201105-MySQL blob导出sql文件乱码","date":"2020-11-05T11:32:00.000Z","updated":"2022-12-30T02:12:00.718Z","comments":true,"path":"2020/11/05/2020/20201105-MySQL blob导出sql文件乱码/","link":"","permalink":"https://qiubyte.github.io/2020/11/05/2020/20201105-MySQL blob导出sql文件乱码/","excerpt":"今天想将数据库里quartz的TRIGGERS表导成sql文件，所以很熟练的就使用了mysqldump -h127.0.0.1 -udev -p quartz QRTZ_TRIGGERS &gt;/home/dev/QRTZ_TRIGGERS.sql命令直接操作，但是打开sql文件发现里面居然是乱码的。","text":"今天想将数据库里quartz的TRIGGERS表导成sql文件，所以很熟练的就使用了mysqldump -h127.0.0.1 -udev -p quartz QRTZ_TRIGGERS &gt;/home/dev/QRTZ_TRIGGERS.sql命令直接操作，但是打开sql文件发现里面居然是乱码的。 前言因为之前导出表没有出现过这种情况。所以就查一下怎么解决。 现象表结构12345678910111213141516171819202122232425262728293031CREATE TABLE `QRTZ_TRIGGERS` ( `SCHED_NAME` varchar(120) NOT NULL, `TRIGGER_NAME` varchar(200) NOT NULL, `TRIGGER_GROUP` varchar(200) NOT NULL, `JOB_NAME` varchar(200) NOT NULL, `JOB_GROUP` varchar(200) NOT NULL, `DESCRIPTION` varchar(250) DEFAULT NULL, `NEXT_FIRE_TIME` bigint(13) DEFAULT NULL, `PREV_FIRE_TIME` bigint(13) DEFAULT NULL, `PRIORITY` int(11) DEFAULT NULL, `TRIGGER_STATE` varchar(16) NOT NULL, `TRIGGER_TYPE` varchar(8) NOT NULL, `START_TIME` bigint(13) NOT NULL, `END_TIME` bigint(13) DEFAULT NULL, `CALENDAR_NAME` varchar(200) DEFAULT NULL, `MISFIRE_INSTR` smallint(2) DEFAULT NULL, `JOB_DATA` blob, PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_T_J` (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_T_JG` (`SCHED_NAME`,`JOB_GROUP`), KEY `IDX_QRTZ_T_C` (`SCHED_NAME`,`CALENDAR_NAME`), KEY `IDX_QRTZ_T_G` (`SCHED_NAME`,`TRIGGER_GROUP`), KEY `IDX_QRTZ_T_STATE` (`SCHED_NAME`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_N_STATE` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_N_G_STATE` (`SCHED_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_NEXT_FIRE_TIME` (`SCHED_NAME`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_ST` (`SCHED_NAME`,`TRIGGER_STATE`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`), KEY `IDX_QRTZ_T_NFT_ST_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_STATE`), KEY `IDX_QRTZ_T_NFT_ST_MISFIRE_GRP` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_GROUP`,`TRIGGER_STATE`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 导出sql文件部分内容截取1INSERT INTO `QRTZ_TRIGGERS` VALUES (&apos;dynamicQrtzScheduler&apos;,&apos;tri-65705-eb0e74b1842b4027a377c43220d69054-to&apos;,&apos;trigrp-65705-eb0e74b1842b4027a377c43220d69054&apos;,&apos;job-65705-to&apos;,&apos;jobgrp-65705&apos;,NULL,1604620800000,1604534400000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\\Ã­\\0^Esr\\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\\Ã^B\\0\\0xr\\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\\Ã¨\\ÃÃ»\\Ã](^B\\0^AZ\\0^SallowsTransientDataartz.utils.DirtyFlagMap^S\\Ã¦.Â­(v\\n\\Ã^B\\0^BZ\\0^EdirtyL\\0^Cmapt\\0^OLjava/util/Map;xp^Asr\\0^Qjava.util.HashMap^E^G\\ÃÃ\\Ã^V`\\Ã^C\\0^BF\\0\\nloadFactorI\\0 thresholdxp?@\\0\\0\\0\\0\\0^Lw^H\\0\\0\\0^P\\0\\0\\0^At\\0\\nscheduleIdt\\0 eb0e74b1842b4027a377c43220d69054&apos;dynamicQrtzScheduler&apos;,&apos;tri-65706-b15eb9393c104988b983c0330cd307f2-from&apos;,&apos;trigrp-65706-b15eb9393c104988b983c0330cd307f2&apos;,&apos;job-65706-from&apos;,&apos;jobgrp-65706&apos;,NULL,1604577600000,1604494957613,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\\Ã­\\0^Esr\\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\\Ã^B\\0\\0xr\\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\\Ã¨\\ÃÃ»\\Ã](^B\\0^AZ\\0^SallowsTransientDataxr\\0^]org.quartz.utils.DirtyFlagn\\Ã^B\\0^BZ\\0^EdirtyL\\0^Cmapt\\0^OLjava/util/Map;xp^Asr\\0^Qjava.util.HashMap^E^G\\ÃÃ\\Ã^V`\\Ã^C\\0^BF\\0\\nloadFactorI\\0 thresholdxp?@\\0\\0\\0\\0\\0^Lw^H\\0\\0\\0^P\\0\\0\\0^At\\0\\nscheduleIdt\\0 b15eb9393c104988b983c0330cd307f2x\\0&apos;),(&apos;dynamicQrtzScheduler&apos;,&apos;txxS_5850ed3578dd-65706-b15eb9393c104988b983c0330cd307f2-to&apos;,&apos;trigrp-65706-b15eb9393c104988b983c0330cd307f2&apos;,&apos;job-65706-to&apos;,&apos;jobgrp-65706&apos;,NULL,1598486400000,1598411308915,5,&apos;ERROR&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\\Ã­\\0^Esr\\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\\Ã^B\\0\\0xr\\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\\Ã¨\\ÃÃ»\\Ã](^B\\0^AZ\\0^SallowsTransientDataxr\\0^]org.quartz.utils.DirtyFlagMap^S\\Ã¦.Â­(v\\n\\Ã^B\\0^BZ\\0^EdirtyL\\a/util/Map;xp^Asr\\0^Qjava.util.HashMap^E^G\\ÃÃ\\Ã^V`\\Ã^C\\0^BF\\0\\nloadFactorI\\0 thresholdxp?@\\0\\0\\0\\0\\0^Lw^H\\0\\0\\0^P\\0\\0\\0^At\\0\\nscheduleIdt\\0 b15eb9393c104988b983c0330cd307f2x\\0&apos;),(&apos;dynamicQrtzScheduler&apos;,&apos;tri-65707-c0612608d3e1811430344fca9a1c-from&apos;,&apos;trigrp-65707-c0612608d3ee41b1811430344fca9a1c&apos;,&apos;job-65707-from&apos;,&apos;jobgrp-65707&apos;,NULL,1604534400000,1604457074711,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\\Ã­^Esr\\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\\Ã^B\\0\\0xr\\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\\Ã¨\\ÃÃ»\\Ã](^B\\0^AZ\\0^SallowsTransientDataxr\\0^]org.quartz.utils.DirtyFlagMap^S\\Ã¦.Â­(v\\n\\Ã^B\\0^BZ\\0^EdirtyL\\0^Cmapt\\0^OLjava/util/Map;xp^Asr\\0ashMap^E^G\\ÃÃ\\Ã^V`\\Ã^C\\0^BF\\0\\nloadFactorI\\0 thresholdxp?@\\0\\0\\0\\0\\0^Lw^H\\0\\0\\0^P\\0\\0\\0^At\\0\\nscheduleIdt\\0 c0612608d3ee41b1811430344fca9a1cx\\0&apos;),(&apos;dynamicQrtzScheduler&apos;,&apos;tri-65707-c0612608d3ee41b1811430344fca9a1c-to&apos;,&apos;tri-65707-c0612608d3ee41b1811430344fca9a1c&apos;,&apos;job-65707-to&apos;,&apos;jobgrp-65707&apos;,NULL,1604577600000,1604491200000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\\Ã­\\0^Esr\\0^Uorg.quartz.JobDataMap&lt;9f&lt;83&gt;Ã¨Â¿Â©Â°\\Ã^B\\0\\0xr\\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\\Ã¨\\ÃÃ»\\Ã](^B\\0^AZ\\0^SallowsTransientDataxr\\0^]org.quartz.utils.DirtyFlagMap^S\\Ã¦.Â­(v\\n\\Ã^B\\0^BZ\\0^EdirtyL\\0^Cmapt\\0^OLjava/util/Map;xp^Asr\\0^Qjava.util.HashMap^E^G\\ÃÃ\\Ã^V`\\ 开始以为是文件从centos上下载导windows上编码格式问题，就在原始的centos上打开文件，结果还是乱码的。 解决方法后来在网上搜了搜解决方法，基本就如下两种 指定字符集编码(未解决) 猜测是不是数据库字符编码存在问题，因为表是utf-8编码格式的，所以在导出命令里加了--default-character-set=utf8。但是试了下导出的文件还是乱码的，应该不是这个原因引起的。 blob字段问题(解决) 根据网上的提示，发现表字段JOB_DATA是blob类型的。需要在命令上加上参数--hex-blob,加上命令mysqldump -h127.0.0.1 -udev --hex-blob -p quartz QRTZ_TRIGGERS &gt;/home/dev/QRTZ_TRIGGERS.sql导出后blob类型的字段被转成了16进制。部分sql内容如下1INSERT INTO `QRTZ_TRIGGERS` VALUES (&apos;dynamicQrtzScheduler&apos;,&apos;tri-306056-c077eb0407ec464ebd061c221eead86b-from&apos;,&apos;trigrp-306056-c077eb0407ec464ebd061c221eead86b&apos;,&apos;job-306056-from&apos;,&apos;jobgrp-306056&apos;,NULL,1604976420000,1604371620000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1600138289000,0,NULL,1,0xACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000C7708000000100000000174000A7363686564756C65496474002063303737656230343037656334363465626430363163323231656561643836627800),(&apos;dynamicQrtzScheduler&apos;,&apos;tri-306056-c077eb0407ec464ebd061c221eead86b-to&apos;,&apos;trigrp-306056-c077eb0407ec464ebd061c221eead86b&apos;,&apos;job-306056-to&apos;,&apos;jobgrp-306056&apos;,NULL,1604976720000,1604371920000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1600138289000,0,NULL,1,0xACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000C7708000000100000000174000A7363686564756C65496474002063303737656230343037656334363465626430363163323231656561643836627800), sql重新再导入导新的库里也是可以的，问题终于解决了。 总结 --hex-blob 使用十六进制表示法转储二进制列, 即以16进制导出blob字段数据。 查了下mysql官方mysqldump参数的解释， 网址在最下面相关链接1 123--hex-blobDump binary columns using hexadecimal notation (for example, &apos;abc&apos; becomes 0x616263). The affected data types are BINARY, VARBINARY, BLOB types, BIT, all spatial data types, and other non-binary data types when used with the binary character set. 网上说如果不用–hex-blob参数, mysqldump和MySQL workbench都还是会导致blob字段错乱。本人没有测试过。 相关链接 –hex-blob参数官方解释：https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#option_mysqldump_hex-blob","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://qiubyte.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://qiubyte.github.io/tags/MySQL/"}]},{"title":"commons-pool2的简单使用","slug":"2019/20191031-commons-pool2的简单使用","date":"2019-10-31T12:00:00.000Z","updated":"2022-12-30T02:12:00.718Z","comments":true,"path":"2019/10/31/2019/20191031-commons-pool2的简单使用/","link":"","permalink":"https://qiubyte.github.io/2019/10/31/2019/20191031-commons-pool2的简单使用/","excerpt":"apache commons-pool是apache基金会的一个开源对象池组件，基于此可以快速的建立一个对象池。","text":"apache commons-pool是apache基金会的一个开源对象池组件，基于此可以快速的建立一个对象池。 前言 在开发的过程中，有一种资源连接的创建和初始化所需要的时间比较长，例如数据库连接、IO等，如果频繁的创建和关闭连接，会极大的降低系统的性能，对资源服务的性能稳定也是一种考验。 下面介绍一种方法就是使用对象池，对象池会在初始化的时候创建一定数量的连接，对象池创建的对象实际并不会每次都重新创建和关闭，而是保存在对象池中，每次访问只需要从连接池中获取连接，使用完毕后归还在对象池中即可。这样可以保证程序重复使用连接，从而提高性能。 我们使用开源的组件apache-common-pool2管理mysql连接，来简单介绍common-pool2的使用。 common-pool2的使用maven依赖12345678910111213141516171819202122&lt;commons-pool2.version&gt;2.7.0&lt;/commons-pool2.version&gt;&lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt;&lt;junit.version&gt;5.5.1&lt;/junit.version&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-pool2.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--用于测试用例编写--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; mysql测试相关信息 数据库名：test，表名：t_user，12345678DROP TABLE IF EXISTS `t_user`;CREATE TABLE `t_user` ( `id` bigint(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`))INSERT INTO `t_user` VALUES (1, &apos;zhangsan&apos;, &apos;01d7f40760960e7bd9443513f22ab9af&apos;); 工厂模式创建管理的对象 创建MysqlJdbcFactory需要继承BasePooledObjectFactory这个抽象类 ,它实现了PooledObjectFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import lombok.extern.slf4j.Slf4j;import org.apache.commons.pool2.BasePooledObjectFactory;import org.apache.commons.pool2.PooledObject;import org.apache.commons.pool2.impl.DefaultPooledObject;import java.sql.Connection;import java.sql.DriverManager;/** * @author qiubyte * @date 2019/10/31 19:32 */@Slf4jpublic class MysqlJdbcFactory extends BasePooledObjectFactory&lt;Connection&gt; &#123; private String url; private String className = &quot;com.mysql.cj.jdbc.Driver&quot;; private String username; private String password; public MysqlJdbcFactory(String url, String className, String username, String password) &#123; this.url = url; this.className = className; this.username = username; this.password = password; &#125; public MysqlJdbcFactory(String url, String username, String password) &#123; this.url = url; this.username = username; this.password = password; &#125; /** * 间接实现 PooledObjectFactory#makeObject()方法，表明怎样创建需要管理对象 * * @return 连接 * @throws Exception e */ @Override public Connection create() throws Exception &#123; // 指定连接类型 Class.forName(className); // 获取连接 return DriverManager.getConnection(url, username, password); &#125; /** * 在common-pool2中为了统计管理的对象的一些信息，比如调用次数，空闲时间，上次使用时间等， * 需要对管理的对象进行包装，然后在放入到对象池中 * * @param connection 对象池要管理的对象 * @return 返回包装后的PooledObject对象 */ @Override public PooledObject&lt;Connection&gt; wrap(Connection connection) &#123; return new DefaultPooledObject&lt;&gt;(connection); &#125; /** * 调用该方法激活对象 * * @param p p * @throws Exception e */ @Override public void activateObject(PooledObject&lt;Connection&gt; p) throws Exception &#123; super.activateObject(p); &#125; /** * 归还对象时钝化对象，比如某些对象用完之后需要休眠一段时间 * * @param p p * @throws Exception e */ @Override public void passivateObject(PooledObject&lt;Connection&gt; p) throws Exception &#123; super.passivateObject(p); &#125; /** * testOnBorrow设置为true时，创建对象时调用该方法验证对象的有效性，如果无效直接抛出异常 &quot;Unable to validate object&quot; * testOnReturn设置为true时，归还对象时验证对象是否还有效，比如连接是否还在，如果无效了则不往对象池中放对象 * * @param p p * @return 是否可用 */ @Override public boolean validateObject(PooledObject&lt;Connection&gt; p) &#123; boolean valid = true; try &#123; p.getObject().prepareStatement(&quot;select 1&quot;).execute(); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); valid = false; &#125; return valid; &#125; /** * 归还对象时 * 1.调用validateObject 验证对象失败 * 2.连接池被关闭 * 3.归还对象时连接池中空闲的对象数量大于等于maxIdle * 若符合上述三种情况之一, 都会调用这个方法销毁对象 * 在驱逐线程启动进行检查是符合驱逐策略也会调用这个方法销毁对象 * * @param p p * @throws Exception e */ @Override public void destroyObject(PooledObject&lt;Connection&gt; p) throws Exception &#123; Connection conn = p.getObject(); if (null != conn) &#123; conn.close(); &#125; &#125;&#125; 编写测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import lombok.extern.slf4j.Slf4j;import org.apache.commons.pool2.ObjectPool;import org.apache.commons.pool2.impl.GenericObjectPool;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * jdbc连接池 测试 * @author qiubyte * @date 2019/10/31 19:31 */@Slf4jpublic class JdbcPool2Test &#123; private static final String URL = &quot;jdbc:mysql://172.26.13.10:3306/test&quot;; private static final String USERNAME = &quot;dev&quot;; private static final String PASSWORD = &quot;dev&quot;; private static GenericObjectPoolConfig config = new GenericObjectPoolConfig(); private static ObjectPool&lt;Connection&gt; pool; @BeforeAll public static void beforeAll() &#123; config.setMaxIdle(4); config.setMinIdle(4); config.setMaxTotal(4); config.setTestOnBorrow(true);// config.setTestOnReturn(true); pool = new GenericObjectPool(new MysqlJdbcFactory(URL, USERNAME, PASSWORD), config); &#125; @Test @DisplayName(&quot;使用线程池测试query&quot;) public void testQueryWithPool() &#123; Connection conn = null; PreparedStatement preparedStatement = null; try &#123; conn = pool.borrowObject(); preparedStatement = conn.prepareStatement(&quot;select id, username, password from t_user where id=1&quot;); ResultSet resultSet = preparedStatement.executeQuery(); if (resultSet.next()) &#123; log.info(&quot;name=&#123;&#125;, propvalue=&#123;&#125;, remark=&#123;&#125;&quot;, resultSet.getString(&quot;id&quot;), resultSet.getString(&quot;username&quot;), resultSet.getString(&quot;password&quot;)); &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; finally &#123; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (null != conn) &#123; try &#123; pool.returnObject(conn); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; &#125; &#125; &#125;&#125; 性能测试未使用对象池 首先写一个未使用连接池的方法 123456789101112131415161718192021222324@Test@DisplayName(&quot;每次新创建连接测试&quot;)public void testQueryWithoutPool() throws Exception &#123; Connection conn = null; PreparedStatement preparedStatement = null; MysqlJdbcFactory mysqlJdbcFactory = new MysqlJdbcFactory(URL, USERNAME, PASSWORD); try &#123; conn = mysqlJdbcFactory.create(); preparedStatement = conn.prepareStatement(&quot;select id, username, password from t_user where id=1&quot;); ResultSet resultSet = preparedStatement.executeQuery(); if (resultSet.next()) &#123; log.info(&quot;name=&#123;&#125;, propvalue=&#123;&#125;, remark=&#123;&#125;&quot;, resultSet.getString(&quot;id&quot;), resultSet.getString(&quot;username&quot;), resultSet.getString(&quot;password&quot;)); &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; finally &#123; if (null != preparedStatement) &#123; preparedStatement.close(); &#125; if (null != conn) &#123; conn.close(); &#125; &#125;&#125; 未使用连接池测试 12运行结果：20:05:02.709 [main] INFO com.qiubyte.java.pool.common_pool2.mysql.JdbcPool2Test - name=1, propvalue=zhangsan, remark=01d7f40760960e7bd9443513f22ab9af 性能对比测试 各查询10次， 123456789101112131415161718192021@Test@DisplayName(&quot;使用连接池和不使用对比测试&quot;)public void testQueryCompare() throws Exception &#123; int count = 10; //不使用连接池 long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; count; i++) &#123; testQueryWithoutPool(); &#125; log.info(&quot;query without pool duration = &#123;&#125;ms&quot;, System.currentTimeMillis() - startTime); //使用连接池 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; count; i++) &#123; testQueryWithPool(); &#125; log.info(&quot;query with pool duration = &#123;&#125;ms&quot;, System.currentTimeMillis() - startTime);&#125;运行结果：20:19:00.762 [main] INFO com.qiubyte.java.pool.common_pool2.mysql.JdbcPool2Test - query without pool duration = 219ms20:19:00.784 [main] INFO com.qiubyte.java.pool.common_pool2.mysql.JdbcPool2Test - query with pool duration = 19ms 结果比较明显，相差了10倍不止。 common-pool2应用 使用common-pool2的对象池技术的一个完美例子就是redis的Java客户端JedisPool，可以研究研究。 数据库连接池dbcp项目中是基于commons-pool实现的。 总结上面使用案例比较简单，但体现出来common-pool2可以快速的创建一个安全，强大，简单的对象池工具。如果有需要使用对象池化的操作，可以使用common-pool2快速实现。 相关链接 Apache Commons Pool：http://commons.apache.org/proper/commons-pool 官网示例：http://commons.apache.org/proper/commons-pool/examples.html Jedis github：https://github.com/xetorthio/jedis","categories":[{"name":"Java","slug":"Java","permalink":"https://qiubyte.github.io/categories/Java/"}],"tags":[{"name":"pool","slug":"pool","permalink":"https://qiubyte.github.io/tags/pool/"},{"name":"apache","slug":"apache","permalink":"https://qiubyte.github.io/tags/apache/"}]},{"title":"ArrayList源码分析","slug":"2019/20191022-ArrayList源码分析","date":"2019-10-22T12:00:00.000Z","updated":"2022-12-30T02:12:00.717Z","comments":true,"path":"2019/10/22/2019/20191022-ArrayList源码分析/","link":"","permalink":"https://qiubyte.github.io/2019/10/22/2019/20191022-ArrayList源码分析/","excerpt":"ArrayList的列表对象实质上是存储在一个引用型数组里的。源码基于jdk1.8版本。","text":"ArrayList的列表对象实质上是存储在一个引用型数组里的。源码基于jdk1.8版本。 ArrayList数据结构正如上所说，ArrayList内部采用数组数据结构存储，首先来看下一下源码. 123456789101112131415161718192021222324252627/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; DEFAULT_CAPACITY:默认初始化容量为10，但使用无参数构造方法创建ArrayList对象时并不会直接创建默认初始化容量的存储空间，这个应该时jdk的优化，下面会展开说明。 EMPTY_ELEMENTDATA:空数组对象。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA:空对象，如果使用无参数构造函数创建，则默认对象内容默认是该数组对象。 elementData:当前数据对象存放地方，当前对象不参与序列化 。初始化时为DEFAULTCAPACITY_EMPTY_ELEMENTDATA空对象，第一次add()的时候初始容量10。 size:存储当前数组实际存储数据长度。 ArrayList的构造函数无参数构造函数 无参数构造函数。创建的ArrayList对象中的elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA,初始化容量为0,size为0,当进行第一次add的时候，elementData将会变成默认的长度：10. 123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 我们通过反射获取elementData参数，输出无参数ArrayList容量。 12345678910111213@Testpublic void testEmptyArrayListCapacity() throws NoSuchFieldException, IllegalAccessException &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Field field = ArrayList.class.getDeclaredField(&quot;elementData&quot;); field.setAccessible(true); Object[] objs = (Object[]) field.get(list); System.out.println(&quot;capacity=&quot; + objs.length); System.out.println(&quot;size=&quot; + list.size());&#125;输出结果:capacity=0size=0 带int类型的构造函数 如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下： 1234567891011121314151617/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125; 我们通过反射获取elementData参数，输出带初始化容量参数ArrayList容量。 1234567891011121314@Test@DisplayName(&quot;查看初始容量参数ArrayList的容量和大小&quot;)public void testInitArrayListCapacity() throws NoSuchFieldException, IllegalAccessException &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(5); Field field = ArrayList.class.getDeclaredField(&quot;elementData&quot;); field.setAccessible(true); Object[] objs = (Object[]) field.get(list); System.out.println(&quot;capacity=&quot; + objs.length); System.out.println(&quot;size=&quot; + list.size());&#125;输出结果:capacity=5size=0 带Collection的构造函数 将collection对象转换成数组，然后将数组的地址的赋给elementData。更新size值为传入Collection对象elementData的size。 如果size==0值,直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData 如果size!=0，则执行Arrays.copy方法，把collection对象的内容copy到elementData中。Arrays.copyOf使用System.arraycopy实现。1234567891011121314151617181920212223242526272829/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&apos;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; ArrayList的扩容逻辑add(E e)为例讲解扩容 以add(E e)方法来看ArrayList时如何进行扩容的。首先看add(E e)源码，添加了注释。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; //确认当前当前size+1和容量对比，确认是否需要扩容。 ensureCapacityInternal(size + 1); //因为数组下标是从0开始，最后将e对象放在elementData的size的位置。 //先运算后++，所以此段代码理解为elementData[size] = e; size++; elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;//计算容量private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; //无参数的构造函数初始化elementData会为DEFAULTCAPACITY_EMPTY_ELEMENTDATA,所以这里会有此判断 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //取DEFAULT_CAPACITY和minCapacity的最大值。 //所以如果是个空列表，第一次add操作会扩容为默认容量10 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //计算出来需要的容量 &gt; 当前elementData容量会进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code //oldCapacity原始容量 int oldCapacity = elementData.length; //newCapacity新扩充容量，即扩充后的容量 = oldCapacity + （oldCapacity*0.5）向下取整。例如容量为oldCapacity=10，newCapacity=10+5=15 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果newCapacity扩容为原来的1.5倍还是比minCapacity小，则使用minCapacity的容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8, 需要分配的容量比MAX_ARRAY_SIZE还要大，会调用hugeCapacity方法分配容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 将老数组拷贝到新容量的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; //溢出了，抛错 if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); //没有达到MAX_ARRAY_SIZE则分配MAX_ARRAY_SIZE的容量，&gt; MAX_ARRAY_SIZE则分配Integer.MAX_VALUE容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用System.arraycopy方法复制，native方法速度快。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 扩容逻辑从源码看到一共有五种扩容逻辑。 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA并且当前add的长度&lt;=10的时候，容量由0扩容为10 正常情况下新的容量为原来的1.5倍, 扩容后的newCapacity &gt;= 原始容量+当前add添加的minCapacity,新容量为newCapacity = oldCapacity + (int)(oldCapacity*0.5)。 扩容1.5倍之后的newCapacity &lt; 原始容量+当前add添加的minCapacity，新容量大小为原始容量+当前add添加的minCapacity 计算出来的newCapacity &gt; MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8), 原始容量 &lt; MAX_ARRAY_SIZE, 则新容量为MAX_ARRAY_SIZE 计算出来的newCapacity &gt; MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8), 原始容量 &gt;= MAX_ARRAY_SIZE, 则新容量为Integer.MAX_VALUE 最大容量 我们来看下MAX_ARRAY_SIZE注释： 1234567/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 注释说的很明确，ArrayList在有些虚拟机上保留几个字节（8个字节），所以在这些虚拟机上最大容量是Integer.MAX_VALUE-8。正常情况下最大容量是Integer.MAX_VALUE。ArrayList中这段代码，小于0会报oom, 如果大于MAX_ARRAY_SIZE返回的是Integer.MAX_VALUE，但是在部分虚拟机上会报oom。 remove删除后容量变化 remove删除某个下标的元素，该下标之后的元素通过System.arraycopy方法相当前移一位,但容量不会变化,也就是说删除不会进行缩容处理。 1234567891011121314151617181920/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 验证删除前后容量不会变化。 1234567891011121314151617181920@Test@DisplayName(&quot;remove后容量&quot;)public void testAfterRemoveCapacity() throws NoSuchFieldException, IllegalAccessException &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(10000); Field field = ArrayList.class.getDeclaredField(&quot;elementData&quot;); field.setAccessible(true); Object[] objs = (Object[]) field.get(list); list.add(1); System.out.println(&quot;before remove capacity=&quot; + objs.length); System.out.println(&quot;before remove size=&quot; + list.size()); list.remove(0); System.out.println(&quot;after remove capacity=&quot; + objs.length); System.out.println(&quot;after remove size=&quot; + list.size());&#125;结果：before remove capacity=10000before remove size=1after remove capacity=10000after remove size=0 ArrayList 遍历for遍历方式 先插入100条数据，然后使用for方式遍历，通过get方法获取对应下标存储的对象。1234567891011121314@Testpublic void testArrayListTraverseByFor() &#123; int size = 100; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i); //TODO something &#125; System.out.println(System.currentTimeMillis() - startTime);&#125; foreach遍历方式 先插入100条数据，然后使用foreach方式遍历。1234567891011121314@Test@DisplayName(&quot;foreach方式遍历&quot;)public void testArrayListTraverseByForeach() &#123; int size = 100; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (Integer i : list) &#123; //TODO something &#125; System.out.println(System.currentTimeMillis() - startTime);&#125; 迭代器遍历方式 先插入100条数据，然后使用Iterator遍历,通过hasNext()方法判断是否结束，next方法获取当前值。123456789101112131415@Test@DisplayName(&quot;迭代器方式遍历&quot;)public void testArrayListTraverseByIterator() &#123; int size = 100; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (Iterator&lt;Integer&gt; it = list.iterator(); it.hasNext();) &#123; it.next(); //TODO something &#125; System.out.println(System.currentTimeMillis() - startTime);&#125; 性能对比 首先我们创建容量为一千万的ArrayList，写入数据，通过三种方式遍历比较耗时情况。 12345678910111213141516171819202122232425@Test@DisplayName(&quot;ArrayList遍历性能对比&quot;)public void testArrayListTraverse() &#123; int size = 10000000; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i); //TODO something &#125; System.out.println(&quot;for方式耗时 = &quot; + (System.currentTimeMillis() - startTime)); for (Integer i : list) &#123; //TODO something &#125; System.out.println(&quot;foreach方式耗时 = &quot; + (System.currentTimeMillis() - startTime)); startTime = System.currentTimeMillis(); for (Iterator i = list.iterator(); i.hasNext(); ) &#123; i.next(); //TODO something &#125; System.out.println(&quot;迭代器方式耗时 = &quot; + (System.currentTimeMillis() - startTime));&#125; 结果如下所示。通过对比看到耗时情况对比 for &lt; 迭代器Iterator &lt; foreach。所以对于ArrayList来说遍历性能排序，for &gt; 迭代器Iterator &gt; foreach。 123for方式耗时 = 3foreach方式耗时 = 24迭代器方式耗时 = 4 ArryList相关问题ArrayList异常抛出常见场景 IllegalArgumentException 构造方法ArrayList(int initialCapacity) 初始化initialCapacity填写为负数， subList(int fromIndex, int toIndex)的fromIndex &gt; toIndex NullPointerException 构造方法ArrayList(Collection&lt;? extends E&gt; c) collection传入为null addAll(Collection&lt;? extends E&gt; c) collection传入为null addAll(int index, Collection&lt;? extends E&gt; c) collection传入为null IndexOutOfBoundsException get(int index) index下标越界 set(int index, E element) index下标越界 add(int index, E element) index下标越界 remove(int index) index下标越界 addAll(int index, Collection&lt;? extends E&gt; c) index下标越界 removeRange(int fromIndex, int toIndex) 下标越界 subList(int fromIndex, int toIndex) 下标越界 NoSuchElementException 迭代器next或者previous操作越界 ConcurrentModificationException 多线程同时操作添加或删除操作 IllegalStateException 迭代器设置、删除操作未先next操作的情况 ArrayList安全的remove操作 for循环里删除，使用外部定义的size会抛IndexOutOfBoundsException 1234567891011121314@Testpublic void testRemoveException() &#123; int size = 10; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; for (int i = 0; i &lt; size; i++) &#123; list.remove(i); &#125;&#125;结果：java.lang.IndexOutOfBoundsException: Index: 5, Size: 5 for循环里删除，使用ArrayList的size，可见size时一直在变化的。最终数据并没有删除完，还剩下一半的数据。如果想删除完可以将list.remove(i);替换为list.remove(0);，数组中的数据一直在变，下标也在变动。想匹配删除某个元素也比较麻烦，所以这种删除应用起来也比较鸡肋。 123456789101112131415161718192021@Testpublic void testRemoveByForArraListSize() &#123; int size = 10; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i); System.out.println(&quot;size=&quot; + list.size()); &#125; System.out.println(&quot;end size=&quot; + list.size());&#125;结果：size=9size=8size=7size=6size=5end size=5 使用迭代器，边遍历边删除元素。可以在it.remove();前做逻辑判断等。 1234567891011121314151617@Testpublic void testRemoveByIterator() &#123; int size = 10; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; list.add(i); &#125; for (Iterator it = list.iterator(); it.hasNext();) &#123; it.next(); //TODO if it.remove(); &#125; System.out.println(&quot;end size=&quot; + list.size());&#125;结果：end size=0 ArrayList是非线程安全 如果第一个线程在删除，第二个线程在添加，第三个线程在读取。ArrayList的size会变化，具体变成多少是不确定的，所以很容易出现IndexOutOfBoundsException。 避免方式 采用单线程处理业务员。 使用CopyOnWriteArrayList。 对ArrayList的操作全部加锁，synchronized或者Lock。 在初始化时用Collections.synchronizedList方法进行包装。","categories":[{"name":"Java","slug":"Java","permalink":"https://qiubyte.github.io/categories/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://qiubyte.github.io/tags/List/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://qiubyte.github.io/tags/ArrayList/"}]},{"title":"mysql8.0 授权远程登录连接","slug":"2019/20191009-mysql8.0授权远程登录连接","date":"2019-10-09T12:00:00.000Z","updated":"2022-12-30T02:12:00.716Z","comments":true,"path":"2019/10/09/2019/20191009-mysql8.0授权远程登录连接/","link":"","permalink":"https://qiubyte.github.io/2019/10/09/2019/20191009-mysql8.0授权远程登录连接/","excerpt":"mysql8不可以root用户直接授权，需要新建用户。","text":"mysql8不可以root用户直接授权，需要新建用户。 问题使用docker安装mysql8，需求开启远程登录连接，但使用grant操作一直报错。之前使用5.7版本的时候是没有问题的，所以认为应该是版本问题导致的，MySQL8应该修改了赋予权限的方式。 12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos;;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;IDENTIFIED BY &apos;root&apos;&apos; at line 1 原因新版本将创建账户和赋予权限的方式分开，mysql8不可以root用户直接授权，需要新建用户。 解决方法 创建dev用户(以dev用户为例)123# 新建dev用户mysql&gt; create user &apos;dev&apos;@&apos;%&apos; identified with mysql_native_password by &apos;dev&apos;;Query OK, 0 rows affected (0.11 sec) MySQL8和5的密码加密方式不同，mysql_native_password是5的加密方式。mysql已经将之前的mysql_native_password认证，修改成了caching_sha2_password认证方式。所以，使用类似于navicat或是sqlyog这些客户端时，默认使用还是mysql_native_password认证方式，所以即使输入正确的用户和密码依然登录不成功。客户端新版未测试过，不清楚是否已经支持 查看下表里是否有dev用户，host是否为% 12345678910111213# 查看mysql库user表mysql&gt; select user,host from user;+------------------+-----------+| user | host |+------------------+-----------+| dev | % || healthchecker | localhost || mysql.infoschema | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+------------------+-----------+6 rows in set (0.00 sec) 赋予权限, (修改权限时在后面加with grant option) 123# 将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等。mysql&gt; grant all on *.* to &apos;dev&apos;@&apos;%&apos;;Query OK, 0 rows affected (0.10 sec) 刷新权限 123# 刷新权限mysql&gt; flush privileges;Query OK, 0 rows affected (0.05 sec) 再次使用Navicat测试,连接成功！","categories":[{"name":"software","slug":"software","permalink":"https://qiubyte.github.io/categories/software/"},{"name":"mysql","slug":"software/mysql","permalink":"https://qiubyte.github.io/categories/software/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://qiubyte.github.io/tags/mysql/"}]},{"title":"Tomcat too many open files","slug":"2019/20190929-Tomcat too many open files","date":"2019-09-28T16:00:00.000Z","updated":"2022-12-30T02:12:00.716Z","comments":true,"path":"2019/09/29/2019/20190929-Tomcat too many open files/","link":"","permalink":"https://qiubyte.github.io/2019/09/29/2019/20190929-Tomcat too many open files/","excerpt":"tomcat运行一段时间之后出现文件句柄数过多的情况,java.net.SocketException: Too many open files","text":"tomcat运行一段时间之后出现文件句柄数过多的情况,java.net.SocketException: Too many open files 网上解决方法A couple of days ago we ran into the infamous “too many open files” when our Tomcat web server was under load. There are several blogs around the internet that tries to deal with this issue but none of them seemed to do the trick for us. Usually what you do is to set the ulimit to a greater value (it’s something like 1024 by default). But in order to make it permanent after reboot the first thing suggested is to update the /proc/sys/fs/file-max file and increase the value then edit the /etc/security/limits.conf and add the following line * - nofile 2048 (see here for more details). But none of this worked for us. We saw that when doing 1cat /proc/&lt;tomcat pid&gt;/limits the limit was still set to the initial value of 1024: 1234567891011121314151617Limit Soft Limit Hard Limit UnitsMax cpu time unlimited unlimited secondsMax file size unlimited unlimited bytesMax data size unlimited unlimited bytesMax stack size 8388608 unlimited bytesMax core file size 0 unlimited bytesMax resident set unlimited unlimited bytesMax processes 63810 63810 processes&lt;b&gt;Max open files 1024 1024 files&lt;/b&gt;Max locked memory 65536 65536 bytesMax address space unlimited unlimited bytesMax file locks unlimited unlimited locksMax pending signals 63810 63810 signalsMax msgqueue size 819200 819200 bytesMax nice priority 0 0Max realtime priority 0 0Max realtime timeout unlimited unlimited us It was not until we found this thread that the reason and solution became clear. Our Tomcat instance was started as a service during boot and there’s a bug discovered and filed (with patch) in 2005 that doesn’t seem to have been resolved yet. The bug reveals itself by ignoring the max number of open files limit when starting daemons in Ubuntu/Debain. So the work-around suggested by “BOK” was to edit /etc/init.d/tomcat and add: 12ulimit -Hn 16384ulimit -Sn 16384 Finally the max number of open files for Tomcat was increased! 以上摘自：https://blog.jayway.com/2012/02/11/how-to-really-fix-the-too-many-open-files-problem-for-tomcat-in-ubuntu/ 分析 打开的文件过多，一般来说是由于应用程序对资源使用不当造成，比如没有及时关闭Socket或数据库连接等。但也可能应用确实需要打开比较多的文件句柄，而系统本身的设置限制了这一数量。 Tomcat将主动打开尽可能多的文件句柄，并将硬限制设置为如此高的数量将导致有问题的虚拟机可以消耗大量内存。 12345查看系统允许打开的最大文件数cat /proc/sys/fs/file-maxtomcat文件句柄数cat /proc/&lt;tomcat pid&gt;/limits 不仅要关注系统最大文件句柄数，还要关注tomcat启动能使用的最大句柄数。 在I/O操作之后需要在finally里调用close()。","categories":[{"name":"software","slug":"software","permalink":"https://qiubyte.github.io/categories/software/"},{"name":"tomcat","slug":"software/tomcat","permalink":"https://qiubyte.github.io/categories/software/tomcat/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://qiubyte.github.io/tags/tomcat/"}]},{"title":"SpringBoot RestTemplate 忽略https证书","slug":"2019/20180111-SpringBoot-RestTemplate 忽略https证书","date":"2018-01-11T12:00:00.000Z","updated":"2022-12-30T02:12:00.716Z","comments":true,"path":"2018/01/11/2019/20180111-SpringBoot-RestTemplate 忽略https证书/","link":"","permalink":"https://qiubyte.github.io/2018/01/11/2019/20180111-SpringBoot-RestTemplate 忽略https证书/","excerpt":"SpringBoot RestTemplate 忽略https证书的方法","text":"SpringBoot RestTemplate 忽略https证书的方法 忽略Https证书方法话不多说直接上代码. 添加Http忽略证书代码 123456789101112131415161718192021222324252627public class HttpClientFactory &#123; private static final int readTimeout = 5000; private static final int connectTimeout = 5000; public static CloseableHttpClient acceptsUntrustedCertsHttpClient() throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException &#123; SSLConnectionSocketFactory sslsf = null; //忽略ssl证书 try &#123; SSLContext sslContext = org.apache.http.conn.ssl.SSLContexts.custom().useTLS().loadTrustMaterial(null, new TrustSelfSignedStrategy() &#123; @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;).build(); sslsf = new SSLConnectionSocketFactory(sslContext, new String[]&#123;&quot;TLSv1.2&quot;&#125;, null, SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; RequestConfig defaultRequestConfig = RequestConfig.custom().setSocketTimeout(readTimeout) .setConnectTimeout(connectTimeout).setStaleConnectionCheckEnabled(true).build(); return HttpClients.custom().setSSLSocketFactory(sslsf).setDefaultRequestConfig(defaultRequestConfig).build(); &#125;&#125; RestTemplate bean初始代码 12345678910@Bean@LoadBalancedRestTemplate restTemplate() throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException &#123; CloseableHttpClient httpClient = HttpClientFactory.acceptsUntrustedCertsHttpClient(); HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory); restTemplate.setErrorHandler(new ResponseErrorHandler()); return restTemplate;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"https://qiubyte.github.io/categories/Java框架/"},{"name":"SpringBoot","slug":"Java框架/SpringBoot","permalink":"https://qiubyte.github.io/categories/Java框架/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://qiubyte.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://qiubyte.github.io/tags/SpringBoot/"}]}]}