<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qiubyte</title>
  
  <subtitle>技术菜鸟!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiubyte.github.io/"/>
  <updated>2022-12-30T02:51:55.427Z</updated>
  <id>https://qiubyte.github.io/</id>
  
  <author>
    <name>qiubyte</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>maven多模块项目指定module打包</title>
    <link href="https://qiubyte.github.io/2022/12/07/2022/maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%AE%9Amodule%E6%89%93%E5%8C%85/"/>
    <id>https://qiubyte.github.io/2022/12/07/2022/maven多模块项目指定module打包/</id>
    <published>2022-12-07T13:45:00.000Z</published>
    <updated>2022-12-30T02:51:55.427Z</updated>
    
    <content type="html"><![CDATA[<p>maven项目由多个module，只想打指定的module如何执行命令?</p><a id="more"></a><h2 id="指定module打包"><a href="#指定module打包" class="headerlink" title="指定module打包"></a>指定module打包</h2><h3 id="项目结构如下"><a href="#项目结构如下" class="headerlink" title="项目结构如下"></a>项目结构如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">multi-parent                                         </span><br><span class="line">├── multi-config                      -- 配置中心</span><br><span class="line">├── multi-web                         -- web目录</span><br><span class="line">├── multi-model                       -- model</span><br><span class="line">├── multi-facade                      -- 门面封装</span><br><span class="line">├── multi-core                        -- 核心业务</span><br><span class="line">├── multi-dao                         -- 数据层</span><br><span class="line">└── multi-util                        -- 工具</span><br></pre></td></tr></table></figure><ol><li>直接进入到项目的根目录下</li><li>使用maven打包，相关命令示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 只打web</span><br><span class="line">mvn clean package -pl multi-web -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">-- 打web和web依赖module的包</span><br><span class="line">mvn clean package -pl multi-web -am -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li></ol><p>使用命令说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clean：  清空生成的文件</span><br><span class="line">package：生成target目录，编译、测试代码，生成测试报告，生成jar/war文件</span><br><span class="line">-pl：    打包指定模块，以逗号分隔</span><br><span class="line">-am：    打包所指定模块的依赖模块的依赖，含有传递依赖</span><br><span class="line">-P：     指定环境</span><br><span class="line">-rf：    按指定顺序开始打包</span><br><span class="line">-Dmaven.test.skip ：跳过测试，不然所有测试类都要执行而且必须要正确通过</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;maven项目由多个module，只想打指定的module如何执行命令?&lt;/p&gt;
    
    </summary>
    
    
      <category term="maven" scheme="https://qiubyte.github.io/categories/maven/"/>
    
    
      <category term="tools" scheme="https://qiubyte.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot不使用配置中心实现本地配置文件定时动态刷新</title>
    <link href="https://qiubyte.github.io/2021/08/04/2021/SpringBoot%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/"/>
    <id>https://qiubyte.github.io/2021/08/04/2021/SpringBoot不使用配置中心实现本地配置文件定时动态刷新/</id>
    <published>2021-08-04T12:05:00.000Z</published>
    <updated>2022-12-30T02:12:00.719Z</updated>
    
    <content type="html"><![CDATA[<p>由于还没有接入nacos配置中心，所以需要出一个版本更新本地动态刷新配置的功能，实现配置的动态更新。经过研究发现SpringCloud已经提供了手动接口/actuator/refresh方式刷新的功能，这里再进行处理下实现定时任务动态刷新配置。</p><a id="more"></a><h2 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h2><p>SpringBoot版本2.3.10.RELEASE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.8.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="首先集成SpringCloud中的refresh刷新功能"><a href="#首先集成SpringCloud中的refresh刷新功能" class="headerlink" title="首先集成SpringCloud中的refresh刷新功能"></a>首先集成SpringCloud中的refresh刷新功能</h2><h3 id="上面已经添加了所有的依赖包。"><a href="#上面已经添加了所有的依赖包。" class="headerlink" title="上面已经添加了所有的依赖包。"></a>上面已经添加了所有的依赖包。</h3><p>依赖spring-cloud-starter-config来实现配置更新，所以必须要有</p><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><p>application.yml配置文件添加配置test.version, 必须要添加endpoints refresh对外暴露接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8011</span><br><span class="line">  undertow:</span><br><span class="line">    threads:</span><br><span class="line">      io: 10</span><br><span class="line">      worker: 40</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: health,info,prometheus,refresh</span><br><span class="line">test:</span><br><span class="line">  version: 1.0.0</span><br></pre></td></tr></table></figure><h3 id="RefreshScope注解"><a href="#RefreshScope注解" class="headerlink" title="@RefreshScope注解"></a>@RefreshScope注解</h3><p>在配置获取参数的地方加上@RefreshScope注解，必须要加这个注解才能够实现配置刷新。(@Data是Lombok注解)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@RefreshScope</span><br><span class="line">@Component(&quot;propertyConfig&quot;)</span><br><span class="line">public class PropertyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;test.version:false&#125;&quot;)</span><br><span class="line">    private String testVersion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加controller"><a href="#添加controller" class="headerlink" title="添加controller"></a>添加controller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">public class VersionController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PropertyConfig propertyConfig;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &#123;&quot;/test/version&quot;&#125;, method = RequestMethod.GET)</span><br><span class="line">    public String testVersion() &#123;</span><br><span class="line">        return propertyConfig.getTestVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷新步骤和现象"><a href="#刷新步骤和现象" class="headerlink" title="刷新步骤和现象"></a>刷新步骤和现象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器或着postman调用 http://localhost:8011/test/version接口。</span><br><span class="line">返回结果：1.0.0</span><br><span class="line"></span><br><span class="line">2. application.yml配置文件修改</span><br><span class="line">test:</span><br><span class="line">  version: 2.0.0</span><br><span class="line"></span><br><span class="line">3. post方式 调用 http://localhost:8011/actuator/refresh， 注意这里一定是post。</span><br><span class="line">请求会返回已经被刷新的配置key列表：</span><br><span class="line">[</span><br><span class="line">    &quot;test.version&quot;</span><br><span class="line">]</span><br><span class="line">  </span><br><span class="line">4. 重复1的逻辑，调用 http://localhost:8011/test/version接口。</span><br><span class="line">返回结果：2.0.0</span><br></pre></td></tr></table></figure><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ol><li><code>http://localhost:8011/actuator/refresh</code> 接口必须要用post方式调用。</li><li>比如在idea中运行，<strong>修改的配置文件一定是编译目录下的yml配置文件</strong>，一般在idea中是橘黄色标识 target/classes下的application.yml</li></ol><h2 id="分析refresh的实现"><a href="#分析refresh的实现" class="headerlink" title="分析refresh的实现"></a>分析refresh的实现</h2><h3 id="找到-actuator-refresh接口的实现类"><a href="#找到-actuator-refresh接口的实现类" class="headerlink" title="找到/actuator/refresh接口的实现类"></a>找到<code>/actuator/refresh</code>接口的实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Endpoint(id = &quot;refresh&quot;)</span><br><span class="line">public class RefreshEndpoint &#123;</span><br><span class="line"></span><br><span class="line">private ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">public RefreshEndpoint(ContextRefresher contextRefresher) &#123;</span><br><span class="line">this.contextRefresher = contextRefresher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@WriteOperation</span><br><span class="line">public Collection&lt;String&gt; refresh() &#123;</span><br><span class="line">Set&lt;String&gt; keys = this.contextRefresher.refresh();</span><br><span class="line">return keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>发现就是使用 contextRefresher.refresh() 方法实现刷新的。所以我们可以利用这个方法来自己控制什么时候动态刷新配置。</li><li>感兴趣可以深入看一下源码内部实现。</li></ol><h2 id="集成schedule任务定时刷新"><a href="#集成schedule任务定时刷新" class="headerlink" title="集成schedule任务定时刷新"></a>集成schedule任务定时刷新</h2><h3 id="开启schedule"><a href="#开启schedule" class="headerlink" title="开启schedule"></a>开启schedule</h3><p>Application上加上@EnableScheduling注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时刷新配置任务代码"><a href="#定时刷新配置任务代码" class="headerlink" title="定时刷新配置任务代码"></a>定时刷新配置任务代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.actuate.endpoint.annotation.WriteOperation;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.cloud.context.refresh.ContextRefresher;</span><br><span class="line">import org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">@RefreshScope</span><br><span class="line">@Component</span><br><span class="line">public class PropertiesRefreshTask &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(PropertiesRefreshTask.class);</span><br><span class="line">    /**</span><br><span class="line">     * 文件更新时间</span><br><span class="line">     */</span><br><span class="line">    private long fileUpdateTime = 0L;</span><br><span class="line">    /**</span><br><span class="line">     * 这里是配置文件的目录</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;yml.path:/usr/local/lark&#125;&quot;)</span><br><span class="line">    private String ymlPath;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 30s检查一次</span><br><span class="line">     */</span><br><span class="line">    @WriteOperation</span><br><span class="line">    @Scheduled(fixedDelay = 30000L)</span><br><span class="line">    public void propertiesRefreshTask() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File file = new File(ymlPath + &quot;/application.yml&quot;);</span><br><span class="line">            // 检测文件是否存在</span><br><span class="line">            if (!file.exists()) &#123;</span><br><span class="line">                log.warn(&quot;application.yml not exist&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            long lastModifiedTime = file.lastModified();</span><br><span class="line">            // 文件更新时间和记录对比</span><br><span class="line">            if (fileUpdateTime == 0 || fileUpdateTime &gt;= lastModifiedTime) &#123;</span><br><span class="line">                fileUpdateTime = lastModifiedTime;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; keys = contextRefresher.refresh();</span><br><span class="line">            log.info(&quot;propertiesRefresh keys=&#123;&#125;&quot;, keys);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;propertiesRefresh exception=&#123;&#125;&quot;, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷新步骤和现象-1"><a href="#刷新步骤和现象-1" class="headerlink" title="刷新步骤和现象"></a>刷新步骤和现象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器或着postman调用 http://localhost:8011/test/version接口</span><br><span class="line">返回结果：1.0.0</span><br><span class="line"></span><br><span class="line">2. application.yml配置文件修改</span><br><span class="line">test:</span><br><span class="line">  version: 2.0.0</span><br><span class="line"></span><br><span class="line">3. 等待30s时间</span><br><span class="line">  </span><br><span class="line">4. 重复1的逻辑，调用 http://localhost:8011/test/version接口</span><br><span class="line">返回结果：2.0.0</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>这个是没有接入配置中心导致这么使用的原因，还是建议使用配置中心来实现配置动态加载。</li><li>后续会从源码角度分析下SrpingCloud的refresh的实现逻辑及作用范围。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于还没有接入nacos配置中心，所以需要出一个版本更新本地动态刷新配置的功能，实现配置的动态更新。经过研究发现SpringCloud已经提供了手动接口/actuator/refresh方式刷新的功能，这里再进行处理下实现定时任务动态刷新配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 给Controller RequestMapping添加统一路径前缀</title>
    <link href="https://qiubyte.github.io/2021/08/03/2021/SpringBoot%20%E7%BB%99Controller%20RequestMapping%E6%B7%BB%E5%8A%A0%E7%BB%9F%E4%B8%80%E8%B7%AF%E5%BE%84%E5%89%8D%E7%BC%80/"/>
    <id>https://qiubyte.github.io/2021/08/03/2021/SpringBoot 给Controller RequestMapping添加统一路径前缀/</id>
    <published>2021-08-03T13:05:00.000Z</published>
    <updated>2022-12-30T02:12:00.719Z</updated>
    
    <content type="html"><![CDATA[<p>工作中SpringMVC切换成SpringBoot项目遇到另一个问题，因为之前tomcat部署时候webapps下的目录名也是作为路径的，而springboot之后不需要整个路径名称，所以需要兼容老接口加统一的前缀。</p><a id="more"></a><h2 id="首先对使用的springboot版本进行一个描述"><a href="#首先对使用的springboot版本进行一个描述" class="headerlink" title="首先对使用的springboot版本进行一个描述"></a>首先对使用的springboot版本进行一个描述</h2><p>springboot版本2.3.10.RELEASE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><h2 id="方法1-针对Controller部分替换"><a href="#方法1-针对Controller部分替换" class="headerlink" title="方法1(针对Controller部分替换)"></a>方法1(针对Controller部分替换)</h2><ol><li><p>因为只需要对部分老接口添加前缀，所以加了一个注解来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.core.annotation.AliasFor;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 老的 controller层统一使用该注解</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping</span><br><span class="line">public @interface OldRestController &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Alias for &#123;@link RequestMapping#name&#125;.</span><br><span class="line">     */</span><br><span class="line">    @AliasFor(annotation = RequestMapping.class)</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Alias for &#123;@link RequestMapping#value&#125;.</span><br><span class="line">     */</span><br><span class="line">    @AliasFor(annotation = RequestMapping.class)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Alias for &#123;@link RequestMapping#path&#125;.</span><br><span class="line">     */</span><br><span class="line">    @AliasFor(annotation = RequestMapping.class)</span><br><span class="line">    String[] path() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>@OldRestController</code>注解替换以前的<code>@RestController</code>注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@OldRestController</span><br><span class="line">public class AddressController extends BaseController &#123;</span><br><span class="line">    // ...... code....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写一个配置类，针对<code>@OldRestController</code>注解的累全部添加前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 统一添加请求uri前缀</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class PathConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">        configurer</span><br><span class="line">                .addPathPrefix(&quot;/v1/api&quot;, c -&gt; c.isAnnotationPresent(OldRestController.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试一下老接口完全兼容没有问题。</p></li></ol><h2 id="方法2-全局添加"><a href="#方法2-全局添加" class="headerlink" title="方法2(全局添加)"></a>方法2(全局添加)</h2><ol><li>这里其实是对整个项目访问添加前缀，对于静态资源也会加上此前缀。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    servlet:</span><br><span class="line">        context-path: /v1/api</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>由于此项目中只兼容老的接口，新接口有特定的规则，所以采用了方法1。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中SpringMVC切换成SpringBoot项目遇到另一个问题，因为之前tomcat部署时候webapps下的目录名也是作为路径的，而springboot之后不需要整个路径名称，所以需要兼容老接口加统一的前缀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Undertow监听多个端口</title>
    <link href="https://qiubyte.github.io/2021/08/03/2021/SpringBoot%20Undertow%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E7%AB%AF%E5%8F%A3/"/>
    <id>https://qiubyte.github.io/2021/08/03/2021/SpringBoot Undertow监听多个端口/</id>
    <published>2021-08-03T12:05:00.000Z</published>
    <updated>2022-12-30T02:12:00.719Z</updated>
    
    <content type="html"><![CDATA[<p>工作中SpringMVC切换成SpringBoot项目遇到一个问题，需要监听新的端口8011并且需要对老8080端口兼容，所以也需要对8080端口监听。搜了下网上主要都是tomcat启用多个监听，Undertow的基本没有，而实际我们使用的就是Undertow，所以研究了一下，在这里记录一下的。</p><a id="more"></a><h2 id="监听多个端口步骤"><a href="#监听多个端口步骤" class="headerlink" title="监听多个端口步骤"></a>监听多个端口步骤</h2><h3 id="首先对使用的springboot版本进行一个描述"><a href="#首先对使用的springboot版本进行一个描述" class="headerlink" title="首先对使用的springboot版本进行一个描述"></a>首先对使用的springboot版本进行一个描述</h3><p>springboot版本2.3.10.RELEASE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 剔除tomcat包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 使用undertow --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h3><ol><li>server.port=8011是必须要监听的端口</li><li>server.additional-ports=8080是额外需要监听的一系列端口，可以配置多个，以逗号分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8011</span><br><span class="line">  additional-ports: 8080</span><br></pre></td></tr></table></figure></li></ol><h3 id="具体配置代码"><a href="#具体配置代码" class="headerlink" title="具体配置代码"></a>具体配置代码</h3><p>将UndertowBuilderCustomizer添加到UndertowServletWebServerFactory，然后使用Builder添加一个listener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory;</span><br><span class="line">import org.springframework.boot.web.servlet.server.ServletWebServerFactory;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class WebServerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 额外端口监听</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;server.additional-ports:&#125;&quot;)</span><br><span class="line">    private String additionalPorts;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletWebServerFactory undertowFactory() &#123;</span><br><span class="line">        UndertowServletWebServerFactory undertowFactory = new UndertowServletWebServerFactory();</span><br><span class="line">        undertowFactory.addBuilderCustomizers(builder -&gt; &#123;</span><br><span class="line">            if (StringUtils.isBlank(additionalPorts)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] ports = additionalPorts.split(&quot;,&quot;);</span><br><span class="line">            for (String port : ports) &#123;</span><br><span class="line">                builder.addHttpListener(Integer.parseInt(StringUtils.trim(port)), &quot;0.0.0.0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return undertowFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续可以通过netstat命令查看到进程已经监听了两个端口了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>网上搜了比较多的笔记，基本都是复制粘贴的没有什么帮助。搜不到不如自己研究下，对整个流程加载也会更了解。</li><li>虽然自己研究也实现了，但也浪费了一些时间。所以第一步应该想到SpringBoot官方参考指南上查找相关的用法，果然后面在官方参考文档中找到了(详见参考资料2)。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>官网 <a href="https://undertow.io/" target="_blank" rel="noopener">https://undertow.io/</a></li><li>Spring Boot Reference Guide - Enable Multiple Listeners with Undertow <a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#howto-enable-multiple-listeners-in-undertow" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#howto-enable-multiple-listeners-in-undertow</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中SpringMVC切换成SpringBoot项目遇到一个问题，需要监听新的端口8011并且需要对老8080端口兼容，所以也需要对8080端口监听。搜了下网上主要都是tomcat启用多个监听，Undertow的基本没有，而实际我们使用的就是Undertow，所以研究了一下，在这里记录一下的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/categories/SpringBoot/"/>
    
    
      <category term="Undertow" scheme="https://qiubyte.github.io/tags/Undertow/"/>
    
  </entry>
  
  <entry>
    <title>Win10 Synaptics触摸板双指无法模拟右键等问题处理</title>
    <link href="https://qiubyte.github.io/2021/06/26/2021/Win10%E4%BD%BF%E7%94%A8Synaptics%E8%A7%A6%E6%91%B8%E6%9D%BF%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <id>https://qiubyte.github.io/2021/06/26/2021/Win10使用Synaptics触摸板一些问题处理/</id>
    <published>2021-06-26T11:32:00.000Z</published>
    <updated>2022-12-30T02:51:10.918Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些重新安装系统之后出现的一些触摸板多指失灵的一些处理方法。<br>主要针对Synaptics驱动触摸板，其他驱动触摸板没有了解，可以尝试不确定是否有效。</p><a id="more"></a><h2 id="触摸板问题和处理方法"><a href="#触摸板问题和处理方法" class="headerlink" title="触摸板问题和处理方法"></a>触摸板问题和处理方法</h2><h3 id="Synaptics触摸板无法实现双指单击模拟鼠标右键点击"><a href="#Synaptics触摸板无法实现双指单击模拟鼠标右键点击" class="headerlink" title="Synaptics触摸板无法实现双指单击模拟鼠标右键点击"></a>Synaptics触摸板无法实现双指单击模拟鼠标右键点击</h3><p>触摸板双指单击触摸板是可以模拟鼠标右键的，相当于可以打开菜单，如果双指单击触摸板后没有反应，可以参考如下方法处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、打开注册表（快捷键Win+R，输入&quot;regedit&quot;回车即可打开注册表）。</span><br><span class="line">2、直接找到路径&quot;计算机\HKEY_CURRENT_USER\SOFTWARE\Synaptics\SynTP\TouchPadSMB2cTM2334-1&quot;（注意，因为硬件及软件版本的不同，这里具体的名称可能不太一样，不过前面应该都是”TouchPadSMB”)。</span><br><span class="line">3、将其中”2FingerTapAction”项的值改为2。</span><br><span class="line">4、先试一下效果，如果没有效果的话尝试重新启动下电脑。</span><br></pre></td></tr></table></figure><h3 id="触摸板四指手势切换虚拟桌面方向反的"><a href="#触摸板四指手势切换虚拟桌面方向反的" class="headerlink" title="触摸板四指手势切换虚拟桌面方向反的"></a>触摸板四指手势切换虚拟桌面方向反的</h3><p>win10触摸板四指手势可以切换虚拟桌面，如果发现左右滑动时窗口切换方向和滑动方向相反可以尝试修改注册表信息解决下，方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、打开注册表（快捷键Win+R，输入&quot;regedit&quot;回车即可打开注册表）。</span><br><span class="line">2、找到路径 &quot;计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Synaptics\SynTPEnh\ZoneConfig\Win10\4FHorizontal Scrolling&quot;</span><br><span class="line">3、双击修改，就是交换&quot;NegativeCustomZoneID&quot; 和 &quot;PositiveCustomZoneID&quot;的数值数据。（例如:原始NegativeCustomZoneID数值是88，PositiveCustomZoneID数值是87，修改后NegativeCustomZoneID数值是87，PositiveCustomZoneID数值是88。这里数值要按照电脑中实际的数据交换）</span><br><span class="line">4、一般直接可以生效，如果效果没有改变的话尝试重新启动下电脑。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些重新安装系统之后出现的一些触摸板多指失灵的一些处理方法。&lt;br&gt;主要针对Synaptics驱动触摸板，其他驱动触摸板没有了解，可以尝试不确定是否有效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://qiubyte.github.io/categories/tools/"/>
    
    
      <category term="Windows" scheme="https://qiubyte.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>MySQL blob导出sql文件乱码</title>
    <link href="https://qiubyte.github.io/2020/11/05/2020/20201105-MySQL%20blob%E5%AF%BC%E5%87%BAsql%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/"/>
    <id>https://qiubyte.github.io/2020/11/05/2020/20201105-MySQL blob导出sql文件乱码/</id>
    <published>2020-11-05T11:32:00.000Z</published>
    <updated>2022-12-30T02:12:00.718Z</updated>
    
    <content type="html"><![CDATA[<p>今天想将数据库里quartz的TRIGGERS表导成sql文件，所以很熟练的就使用了<code>mysqldump -h127.0.0.1 -udev -p quartz QRTZ_TRIGGERS &gt;/home/dev/QRTZ_TRIGGERS.sql</code>命令直接操作，但是打开sql文件发现里面居然是乱码的。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为之前导出表没有出现过这种情况。所以就查一下怎么解决。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `QRTZ_TRIGGERS` (</span><br><span class="line">  `SCHED_NAME` varchar(120) NOT NULL,</span><br><span class="line">  `TRIGGER_NAME` varchar(200) NOT NULL,</span><br><span class="line">  `TRIGGER_GROUP` varchar(200) NOT NULL,</span><br><span class="line">  `JOB_NAME` varchar(200) NOT NULL,</span><br><span class="line">  `JOB_GROUP` varchar(200) NOT NULL,</span><br><span class="line">  `DESCRIPTION` varchar(250) DEFAULT NULL,</span><br><span class="line">  `NEXT_FIRE_TIME` bigint(13) DEFAULT NULL,</span><br><span class="line">  `PREV_FIRE_TIME` bigint(13) DEFAULT NULL,</span><br><span class="line">  `PRIORITY` int(11) DEFAULT NULL,</span><br><span class="line">  `TRIGGER_STATE` varchar(16) NOT NULL,</span><br><span class="line">  `TRIGGER_TYPE` varchar(8) NOT NULL,</span><br><span class="line">  `START_TIME` bigint(13) NOT NULL,</span><br><span class="line">  `END_TIME` bigint(13) DEFAULT NULL,</span><br><span class="line">  `CALENDAR_NAME` varchar(200) DEFAULT NULL,</span><br><span class="line">  `MISFIRE_INSTR` smallint(2) DEFAULT NULL,</span><br><span class="line">  `JOB_DATA` blob,</span><br><span class="line">  PRIMARY KEY (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`),</span><br><span class="line">  KEY `IDX_QRTZ_T_J` (`SCHED_NAME`,`JOB_NAME`,`JOB_GROUP`),</span><br><span class="line">  KEY `IDX_QRTZ_T_JG` (`SCHED_NAME`,`JOB_GROUP`),</span><br><span class="line">  KEY `IDX_QRTZ_T_C` (`SCHED_NAME`,`CALENDAR_NAME`),</span><br><span class="line">  KEY `IDX_QRTZ_T_G` (`SCHED_NAME`,`TRIGGER_GROUP`),</span><br><span class="line">  KEY `IDX_QRTZ_T_STATE` (`SCHED_NAME`,`TRIGGER_STATE`),</span><br><span class="line">  KEY `IDX_QRTZ_T_N_STATE` (`SCHED_NAME`,`TRIGGER_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`),</span><br><span class="line">  KEY `IDX_QRTZ_T_N_G_STATE` (`SCHED_NAME`,`TRIGGER_GROUP`,`TRIGGER_STATE`),</span><br><span class="line">  KEY `IDX_QRTZ_T_NEXT_FIRE_TIME` (`SCHED_NAME`,`NEXT_FIRE_TIME`),</span><br><span class="line">  KEY `IDX_QRTZ_T_NFT_ST` (`SCHED_NAME`,`TRIGGER_STATE`,`NEXT_FIRE_TIME`),</span><br><span class="line">  KEY `IDX_QRTZ_T_NFT_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`),</span><br><span class="line">  KEY `IDX_QRTZ_T_NFT_ST_MISFIRE` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_STATE`),</span><br><span class="line">  KEY `IDX_QRTZ_T_NFT_ST_MISFIRE_GRP` (`SCHED_NAME`,`MISFIRE_INSTR`,`NEXT_FIRE_TIME`,`TRIGGER_GROUP`,`TRIGGER_STATE`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><h3 id="导出sql文件部分内容截取"><a href="#导出sql文件部分内容截取" class="headerlink" title="导出sql文件部分内容截取"></a>导出sql文件部分内容截取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `QRTZ_TRIGGERS` VALUES (&apos;dynamicQrtzScheduler&apos;,&apos;tri-65705-eb0e74b1842b4027a377c43220d69054-to&apos;,&apos;trigrp-65705-eb0e74b1842b4027a377c43220d69054&apos;,&apos;job-65705-to&apos;,&apos;jobgrp-65705&apos;,NULL,1604620800000,1604534400000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\Ã­\0^Esr\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\Ã^B\0\0xr\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\Ã¨\ÃÃ»\Ã](^B\0^AZ\0^SallowsTransientDataartz.utils.DirtyFlagMap^S\Ã¦.Â­(v\n\Ã^B\0^BZ\0^EdirtyL\0^Cmapt\0^OLjava/util/Map;xp^Asr\0^Qjava.util.HashMap^E^G\ÃÃ\Ã^V`\Ã^C\0^BF\0\nloadFactorI\0    thresholdxp?@\0\0\0\0\0^Lw^H\0\0\0^P\0\0\0^At\0\nscheduleIdt\0 eb0e74b1842b4027a377c43220d69054&apos;dynamicQrtzScheduler&apos;,&apos;tri-65706-b15eb9393c104988b983c0330cd307f2-from&apos;,&apos;trigrp-65706-b15eb9393c104988b983c0330cd307f2&apos;,&apos;job-65706-from&apos;,&apos;jobgrp-65706&apos;,NULL,1604577600000,1604494957613,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\Ã­\0^Esr\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\Ã^B\0\0xr\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\Ã¨\ÃÃ»\Ã](^B\0^AZ\0^SallowsTransientDataxr\0^]org.quartz.utils.DirtyFlagn\Ã^B\0^BZ\0^EdirtyL\0^Cmapt\0^OLjava/util/Map;xp^Asr\0^Qjava.util.HashMap^E^G\ÃÃ\Ã^V`\Ã^C\0^BF\0\nloadFactorI\0      thresholdxp?@\0\0\0\0\0^Lw^H\0\0\0^P\0\0\0^At\0\nscheduleIdt\0 b15eb9393c104988b983c0330cd307f2x\0&apos;),(&apos;dynamicQrtzScheduler&apos;,&apos;txxS_5850ed3578dd-65706-b15eb9393c104988b983c0330cd307f2-to&apos;,&apos;trigrp-65706-b15eb9393c104988b983c0330cd307f2&apos;,&apos;job-65706-to&apos;,&apos;jobgrp-65706&apos;,NULL,1598486400000,1598411308915,5,&apos;ERROR&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\Ã­\0^Esr\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\Ã^B\0\0xr\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\Ã¨\ÃÃ»\Ã](^B\0^AZ\0^SallowsTransientDataxr\0^]org.quartz.utils.DirtyFlagMap^S\Ã¦.Â­(v\n\Ã^B\0^BZ\0^EdirtyL\a/util/Map;xp^Asr\0^Qjava.util.HashMap^E^G\ÃÃ\Ã^V`\Ã^C\0^BF\0\nloadFactorI\0    thresholdxp?@\0\0\0\0\0^Lw^H\0\0\0^P\0\0\0^At\0\nscheduleIdt\0 b15eb9393c104988b983c0330cd307f2x\0&apos;),(&apos;dynamicQrtzScheduler&apos;,&apos;tri-65707-c0612608d3e1811430344fca9a1c-from&apos;,&apos;trigrp-65707-c0612608d3ee41b1811430344fca9a1c&apos;,&apos;job-65707-from&apos;,&apos;jobgrp-65707&apos;,NULL,1604534400000,1604457074711,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\Ã­^Esr\0^Uorg.quartz.JobDataMap&lt;9f&gt;Â°&lt;83&gt;Ã¨Â¿Â©Â°\Ã^B\0\0xr\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\Ã¨\ÃÃ»\Ã](^B\0^AZ\0^SallowsTransientDataxr\0^]org.quartz.utils.DirtyFlagMap^S\Ã¦.Â­(v\n\Ã^B\0^BZ\0^EdirtyL\0^Cmapt\0^OLjava/util/Map;xp^Asr\0ashMap^E^G\ÃÃ\Ã^V`\Ã^C\0^BF\0\nloadFactorI\0      thresholdxp?@\0\0\0\0\0^Lw^H\0\0\0^P\0\0\0^At\0\nscheduleIdt\0 c0612608d3ee41b1811430344fca9a1cx\0&apos;),(&apos;dynamicQrtzScheduler&apos;,&apos;tri-65707-c0612608d3ee41b1811430344fca9a1c-to&apos;,&apos;tri-65707-c0612608d3ee41b1811430344fca9a1c&apos;,&apos;job-65707-to&apos;,&apos;jobgrp-65707&apos;,NULL,1604577600000,1604491200000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1589279232000,0,NULL,1,_binary &apos;Â¬\Ã­\0^Esr\0^Uorg.quartz.JobDataMap&lt;9f&lt;83&gt;Ã¨Â¿Â©Â°\Ã^B\0\0xr\0&amp;org.quartz.utils.StringKeyDirtyFlagMap&lt;82&gt;^H\Ã¨\ÃÃ»\Ã](^B\0^AZ\0^SallowsTransientDataxr\0^]org.quartz.utils.DirtyFlagMap^S\Ã¦.Â­(v\n\Ã^B\0^BZ\0^EdirtyL\0^Cmapt\0^OLjava/util/Map;xp^Asr\0^Qjava.util.HashMap^E^G\ÃÃ\Ã^V`\</span><br></pre></td></tr></table></figure><p>开始以为是文件从centos上下载导windows上编码格式问题，就在原始的centos上打开文件，结果还是乱码的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>后来在网上搜了搜解决方法，基本就如下两种</p><h3 id="指定字符集编码-未解决"><a href="#指定字符集编码-未解决" class="headerlink" title="指定字符集编码(未解决)"></a>指定字符集编码(未解决)</h3><ol><li>猜测是不是数据库字符编码存在问题，因为表是utf-8编码格式的，所以在导出命令里加了<code>--default-character-set=utf8</code>。但是试了下导出的文件还是乱码的，应该不是这个原因引起的。</li></ol><h3 id="blob字段问题-解决"><a href="#blob字段问题-解决" class="headerlink" title="blob字段问题(解决)"></a>blob字段问题(解决)</h3><ol><li>根据网上的提示，发现表字段JOB_DATA是blob类型的。需要在命令上加上参数<code>--hex-blob</code>,加上命令<code>mysqldump -h127.0.0.1 -udev --hex-blob -p quartz QRTZ_TRIGGERS &gt;/home/dev/QRTZ_TRIGGERS.sql</code>导出后blob类型的字段被转成了16进制。部分sql内容如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `QRTZ_TRIGGERS` VALUES (&apos;dynamicQrtzScheduler&apos;,&apos;tri-306056-c077eb0407ec464ebd061c221eead86b-from&apos;,&apos;trigrp-306056-c077eb0407ec464ebd061c221eead86b&apos;,&apos;job-306056-from&apos;,&apos;jobgrp-306056&apos;,NULL,1604976420000,1604371620000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1600138289000,0,NULL,1,0xACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000C7708000000100000000174000A7363686564756C65496474002063303737656230343037656334363465626430363163323231656561643836627800),(&apos;dynamicQrtzScheduler&apos;,&apos;tri-306056-c077eb0407ec464ebd061c221eead86b-to&apos;,&apos;trigrp-306056-c077eb0407ec464ebd061c221eead86b&apos;,&apos;job-306056-to&apos;,&apos;jobgrp-306056&apos;,NULL,1604976720000,1604371920000,5,&apos;WAITING&apos;,&apos;CRON&apos;,1600138289000,0,NULL,1,0xACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000C7708000000100000000174000A7363686564756C65496474002063303737656230343037656334363465626430363163323231656561643836627800),</span><br></pre></td></tr></table></figure></li></ol><p>sql重新再导入导新的库里也是可以的，问题终于解决了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p><code>--hex-blob</code> 使用十六进制表示法转储二进制列, 即以16进制导出blob字段数据。</p></li><li><p>查了下mysql官方mysqldump参数的解释， 网址在最下面相关链接1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--hex-blob</span><br><span class="line"></span><br><span class="line">Dump binary columns using hexadecimal notation (for example, &apos;abc&apos; becomes 0x616263). The affected data types are BINARY, VARBINARY, BLOB types, BIT, all spatial data types, and other non-binary data types when used with the binary character set.</span><br></pre></td></tr></table></figure></li><li><p>网上说如果不用–hex-blob参数, mysqldump和MySQL workbench都还是会导致blob字段错乱。本人没有测试过。</p></li></ol><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li>–hex-blob参数官方解释：<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#option_mysqldump_hex-blob" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#option_mysqldump_hex-blob</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想将数据库里quartz的TRIGGERS表导成sql文件，所以很熟练的就使用了&lt;code&gt;mysqldump -h127.0.0.1 -udev -p quartz QRTZ_TRIGGERS &amp;gt;/home/dev/QRTZ_TRIGGERS.sql&lt;/code&gt;命令直接操作，但是打开sql文件发现里面居然是乱码的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://qiubyte.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://qiubyte.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>commons-pool2的简单使用</title>
    <link href="https://qiubyte.github.io/2019/10/31/2019/20191031-commons-pool2%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://qiubyte.github.io/2019/10/31/2019/20191031-commons-pool2的简单使用/</id>
    <published>2019-10-31T12:00:00.000Z</published>
    <updated>2022-12-30T02:12:00.718Z</updated>
    
    <content type="html"><![CDATA[<p>apache commons-pool是apache基金会的一个开源对象池组件，基于此可以快速的建立一个对象池。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在开发的过程中，有一种资源连接的创建和初始化所需要的时间比较长，例如数据库连接、IO等，如果频繁的创建和关闭连接，会极大的降低系统的性能，对资源服务的性能稳定也是一种考验。</li><li>下面介绍一种方法就是使用对象池，对象池会在初始化的时候创建一定数量的连接，对象池创建的对象实际并不会每次都重新创建和关闭，而是保存在对象池中，每次访问只需要从连接池中获取连接，使用完毕后归还在对象池中即可。这样可以保证程序重复使用连接，从而提高性能。</li><li>我们使用开源的组件apache-common-pool2管理mysql连接，来简单介绍common-pool2的使用。</li></ol><h2 id="common-pool2的使用"><a href="#common-pool2的使用" class="headerlink" title="common-pool2的使用"></a>common-pool2的使用</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;commons-pool2.version&gt;2.7.0&lt;/commons-pool2.version&gt;</span><br><span class="line">&lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt;</span><br><span class="line">&lt;junit.version&gt;5.5.1&lt;/junit.version&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;commons-pool2.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--用于测试用例编写--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="mysql测试相关信息"><a href="#mysql测试相关信息" class="headerlink" title="mysql测试相关信息"></a>mysql测试相关信息</h3><ol><li>数据库名：test，表名：t_user，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `t_user`;</span><br><span class="line">CREATE TABLE `t_user`  (</span><br><span class="line">  `id` bigint(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(255) DEFAULT NULL,</span><br><span class="line">  `password` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">)</span><br><span class="line">INSERT INTO `t_user` VALUES (1, &apos;zhangsan&apos;, &apos;01d7f40760960e7bd9443513f22ab9af&apos;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="工厂模式创建管理的对象"><a href="#工厂模式创建管理的对象" class="headerlink" title="工厂模式创建管理的对象"></a>工厂模式创建管理的对象</h3><ol><li>创建MysqlJdbcFactory需要继承BasePooledObjectFactory这个抽象类 ,它实现了PooledObjectFactory<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.pool2.BasePooledObjectFactory;</span><br><span class="line">import org.apache.commons.pool2.PooledObject;</span><br><span class="line">import org.apache.commons.pool2.impl.DefaultPooledObject;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qiubyte</span><br><span class="line"> * @date 2019/10/31 19:32</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class MysqlJdbcFactory extends BasePooledObjectFactory&lt;Connection&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String url;</span><br><span class="line">    private String className = &quot;com.mysql.cj.jdbc.Driver&quot;;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public MysqlJdbcFactory(String url, String className, String username, String password) &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">        this.className = className;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MysqlJdbcFactory(String url, String username, String password) &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 间接实现 PooledObjectFactory#makeObject()方法，表明怎样创建需要管理对象</span><br><span class="line">     *</span><br><span class="line">     * @return 连接</span><br><span class="line">     * @throws Exception e</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Connection create() throws Exception &#123;</span><br><span class="line">        // 指定连接类型</span><br><span class="line">        Class.forName(className);</span><br><span class="line">        // 获取连接</span><br><span class="line">        return DriverManager.getConnection(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在common-pool2中为了统计管理的对象的一些信息，比如调用次数，空闲时间，上次使用时间等，</span><br><span class="line">     * 需要对管理的对象进行包装，然后在放入到对象池中</span><br><span class="line">     *</span><br><span class="line">     * @param connection 对象池要管理的对象</span><br><span class="line">     * @return 返回包装后的PooledObject对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public PooledObject&lt;Connection&gt; wrap(Connection connection) &#123;</span><br><span class="line">        return new DefaultPooledObject&lt;&gt;(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用该方法激活对象</span><br><span class="line">     *</span><br><span class="line">     * @param p p</span><br><span class="line">     * @throws Exception e</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void activateObject(PooledObject&lt;Connection&gt; p) throws Exception &#123;</span><br><span class="line">        super.activateObject(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 归还对象时钝化对象，比如某些对象用完之后需要休眠一段时间</span><br><span class="line">     *</span><br><span class="line">     * @param p p</span><br><span class="line">     * @throws Exception e</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void passivateObject(PooledObject&lt;Connection&gt; p) throws Exception &#123;</span><br><span class="line">        super.passivateObject(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * testOnBorrow设置为true时，创建对象时调用该方法验证对象的有效性，如果无效直接抛出异常 &quot;Unable to validate object&quot;</span><br><span class="line">     * testOnReturn设置为true时，归还对象时验证对象是否还有效，比如连接是否还在，如果无效了则不往对象池中放对象</span><br><span class="line">     *</span><br><span class="line">     * @param p p</span><br><span class="line">     * @return 是否可用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean validateObject(PooledObject&lt;Connection&gt; p) &#123;</span><br><span class="line">        boolean valid = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            p.getObject().prepareStatement(&quot;select 1&quot;).execute();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">            valid = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 归还对象时</span><br><span class="line">     * 1.调用validateObject 验证对象失败</span><br><span class="line">     * 2.连接池被关闭</span><br><span class="line">     * 3.归还对象时连接池中空闲的对象数量大于等于maxIdle</span><br><span class="line">     * 若符合上述三种情况之一, 都会调用这个方法销毁对象</span><br><span class="line">     * 在驱逐线程启动进行检查是符合驱逐策略也会调用这个方法销毁对象</span><br><span class="line">     *</span><br><span class="line">     * @param p p</span><br><span class="line">     * @throws Exception e</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroyObject(PooledObject&lt;Connection&gt; p) throws Exception &#123;</span><br><span class="line">        Connection conn = p.getObject();</span><br><span class="line">        if (null != conn) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.pool2.ObjectPool;</span><br><span class="line">import org.apache.commons.pool2.impl.GenericObjectPool;</span><br><span class="line">import org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line">import org.junit.jupiter.api.BeforeAll;</span><br><span class="line">import org.junit.jupiter.api.DisplayName;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * jdbc连接池 测试</span><br><span class="line"> * @author qiubyte</span><br><span class="line"> * @date 2019/10/31 19:31</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class JdbcPool2Test &#123;</span><br><span class="line">    private static final String URL = &quot;jdbc:mysql://172.26.13.10:3306/test&quot;;</span><br><span class="line">    private static final String USERNAME = &quot;dev&quot;;</span><br><span class="line">    private static final String PASSWORD = &quot;dev&quot;;</span><br><span class="line"></span><br><span class="line">    private static GenericObjectPoolConfig config = new GenericObjectPoolConfig();</span><br><span class="line">    private static ObjectPool&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    @BeforeAll</span><br><span class="line">    public static void beforeAll() &#123;</span><br><span class="line">        config.setMaxIdle(4);</span><br><span class="line">        config.setMinIdle(4);</span><br><span class="line">        config.setMaxTotal(4);</span><br><span class="line">        config.setTestOnBorrow(true);</span><br><span class="line">//        config.setTestOnReturn(true);</span><br><span class="line">        pool = new GenericObjectPool(new MysqlJdbcFactory(URL, USERNAME, PASSWORD), config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @DisplayName(&quot;使用线程池测试query&quot;)</span><br><span class="line">    public void testQueryWithPool() &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        PreparedStatement preparedStatement = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn = pool.borrowObject();</span><br><span class="line">            preparedStatement = conn.prepareStatement(&quot;select id, username, password from t_user where id=1&quot;);</span><br><span class="line">            ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">            if (resultSet.next()) &#123;</span><br><span class="line">                log.info(&quot;name=&#123;&#125;, propvalue=&#123;&#125;, remark=&#123;&#125;&quot;, resultSet.getString(&quot;id&quot;), resultSet.getString(&quot;username&quot;), resultSet.getString(&quot;password&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (null != preparedStatement) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    preparedStatement.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (null != conn) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    pool.returnObject(conn);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="未使用对象池"><a href="#未使用对象池" class="headerlink" title="未使用对象池"></a>未使用对象池</h3><ol><li><p>首先写一个未使用连接池的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;每次新创建连接测试&quot;)</span><br><span class="line">public void testQueryWithoutPool() throws Exception &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    PreparedStatement preparedStatement = null;</span><br><span class="line">    MysqlJdbcFactory mysqlJdbcFactory = new MysqlJdbcFactory(URL, USERNAME, PASSWORD);</span><br><span class="line">    try &#123;</span><br><span class="line">        conn = mysqlJdbcFactory.create();</span><br><span class="line">        preparedStatement = conn.prepareStatement(&quot;select id, username, password from t_user where id=1&quot;);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        if (resultSet.next()) &#123;</span><br><span class="line">            log.info(&quot;name=&#123;&#125;, propvalue=&#123;&#125;, remark=&#123;&#125;&quot;, resultSet.getString(&quot;id&quot;), resultSet.getString(&quot;username&quot;), resultSet.getString(&quot;password&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (null != preparedStatement) &#123;</span><br><span class="line">            preparedStatement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        if (null != conn) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>未使用连接池测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">20:05:02.709 [main] INFO com.qiubyte.java.pool.common_pool2.mysql.JdbcPool2Test - name=1, propvalue=zhangsan, remark=01d7f40760960e7bd9443513f22ab9af</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能对比测试"><a href="#性能对比测试" class="headerlink" title="性能对比测试"></a>性能对比测试</h3><ol><li><p>各查询10次，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;使用连接池和不使用对比测试&quot;)</span><br><span class="line">public void testQueryCompare() throws Exception &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    //不使用连接池</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        testQueryWithoutPool();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(&quot;query without pool duration = &#123;&#125;ms&quot;, System.currentTimeMillis() - startTime);</span><br><span class="line">    //使用连接池</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        testQueryWithPool();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(&quot;query with pool duration = &#123;&#125;ms&quot;, System.currentTimeMillis() - startTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">20:19:00.762 [main] INFO com.qiubyte.java.pool.common_pool2.mysql.JdbcPool2Test - query without pool duration = 219ms</span><br><span class="line">20:19:00.784 [main] INFO com.qiubyte.java.pool.common_pool2.mysql.JdbcPool2Test - query with pool duration = 19ms</span><br></pre></td></tr></table></figure></li><li><p>结果比较明显，相差了10倍不止。</p></li></ol><h2 id="common-pool2应用"><a href="#common-pool2应用" class="headerlink" title="common-pool2应用"></a>common-pool2应用</h2><ol><li>使用common-pool2的对象池技术的一个完美例子就是redis的Java客户端JedisPool，可以研究研究。</li><li>数据库连接池dbcp项目中是基于commons-pool实现的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面使用案例比较简单，但体现出来common-pool2可以快速的创建一个安全，强大，简单的对象池工具。如果有需要使用对象池化的操作，可以使用common-pool2快速实现。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li>Apache Commons Pool：<a href="http://commons.apache.org/proper/commons-pool/" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-pool</a></li><li>官网示例：<a href="http://commons.apache.org/proper/commons-pool/examples.html" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-pool/examples.html</a></li><li>Jedis github：<a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apache commons-pool是apache基金会的一个开源对象池组件，基于此可以快速的建立一个对象池。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://qiubyte.github.io/categories/Java/"/>
    
    
      <category term="pool" scheme="https://qiubyte.github.io/tags/pool/"/>
    
      <category term="apache" scheme="https://qiubyte.github.io/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="https://qiubyte.github.io/2019/10/22/2019/20191022-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://qiubyte.github.io/2019/10/22/2019/20191022-ArrayList源码分析/</id>
    <published>2019-10-22T12:00:00.000Z</published>
    <updated>2022-12-30T02:12:00.717Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList的列表对象实质上是存储在一个引用型数组里的。<br>源码基于jdk1.8版本。</p><a id="more"></a><h2 id="ArrayList数据结构"><a href="#ArrayList数据结构" class="headerlink" title="ArrayList数据结构"></a>ArrayList数据结构</h2><p>正如上所说，ArrayList内部采用数组数据结构存储，首先来看下一下源码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Default initial capacity.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">/**</span><br><span class="line"> * Shared empty array instance used for empty instances.</span><br><span class="line"> */</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * Shared empty array instance used for default sized empty instances. We</span><br><span class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="line"> * first element is added.</span><br><span class="line"> */</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">/**</span><br><span class="line"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><ol><li><code>DEFAULT_CAPACITY</code>:默认初始化容量为10，但使用无参数构造方法创建ArrayList对象时并不会直接创建默认初始化容量的存储空间，这个应该时jdk的优化，下面会展开说明。</li><li><code>EMPTY_ELEMENTDATA</code>:空数组对象。</li><li><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>:空对象，如果使用无参数构造函数创建，则默认对象内容默认是该数组对象。</li><li><code>elementData</code>:当前数据对象存放地方，当前对象不参与序列化 。初始化时为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>空对象，第一次add()的时候初始容量10。</li><li><code>size</code>:存储当前数组实际存储数据长度。</li></ol><h2 id="ArrayList的构造函数"><a href="#ArrayList的构造函数" class="headerlink" title="ArrayList的构造函数"></a>ArrayList的构造函数</h2><h3 id="无参数构造函数"><a href="#无参数构造函数" class="headerlink" title="无参数构造函数"></a>无参数构造函数</h3><ol><li><p>无参数构造函数。创建的ArrayList对象中的<code>elementData</code>为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>,初始化容量为0,size为0,当进行第一次add的时候，<code>elementData</code>将会变成默认的长度：10.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty list with an initial capacity of ten.</span><br><span class="line"> */</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们通过反射获取<code>elementData</code>参数，输出无参数ArrayList容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testEmptyArrayListCapacity() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Field field = ArrayList.class.getDeclaredField(&quot;elementData&quot;);</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    Object[] objs = (Object[]) field.get(list);</span><br><span class="line">    System.out.println(&quot;capacity=&quot; + objs.length);</span><br><span class="line">    System.out.println(&quot;size=&quot; + list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">capacity=0</span><br><span class="line">size=0</span><br></pre></td></tr></table></figure></li></ol><h3 id="带int类型的构造函数"><a href="#带int类型的构造函数" class="headerlink" title="带int类型的构造函数"></a>带int类型的构造函数</h3><ol><li><p>如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty list with the specified initial capacity.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity  the initial capacity of the list</span><br><span class="line"> * @throws IllegalArgumentException if the specified initial capacity</span><br><span class="line"> *         is negative</span><br><span class="line"> */</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们通过反射获取<code>elementData</code>参数，输出带初始化容量参数ArrayList容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;查看初始容量参数ArrayList的容量和大小&quot;)</span><br><span class="line">public void testInitArrayListCapacity() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(5);</span><br><span class="line">    Field field = ArrayList.class.getDeclaredField(&quot;elementData&quot;);</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    Object[] objs = (Object[]) field.get(list);</span><br><span class="line">    System.out.println(&quot;capacity=&quot; + objs.length);</span><br><span class="line">    System.out.println(&quot;size=&quot; + list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">capacity=5</span><br><span class="line">size=0</span><br></pre></td></tr></table></figure></li></ol><h3 id="带Collection的构造函数"><a href="#带Collection的构造函数" class="headerlink" title="带Collection的构造函数"></a>带Collection的构造函数</h3><ol><li>将collection对象转换成数组，然后将数组的地址的赋给<code>elementData</code>。更新size值为传入Collection对象<code>elementData</code>的size。</li><li>如果size==0值,直接将空对象<code>EMPTY_ELEMENTDATA</code>的地址赋给<code>elementData</code></li><li>如果size!=0，则执行<code>Arrays.copy</code>方法，把collection对象的内容copy到<code>elementData</code>中。<code>Arrays.copyOf</code>使用<code>System.arraycopy</code>实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a list containing the elements of the specified</span><br><span class="line"> * collection, in the order they are returned by the collection&apos;s</span><br><span class="line"> * iterator.</span><br><span class="line"> *</span><br><span class="line"> * @param c the collection whose elements are to be placed into this list</span><br><span class="line"> * @throws NullPointerException if the specified collection is null</span><br><span class="line"> */</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ArrayList的扩容逻辑"><a href="#ArrayList的扩容逻辑" class="headerlink" title="ArrayList的扩容逻辑"></a>ArrayList的扩容逻辑</h2><h3 id="add-E-e-为例讲解扩容"><a href="#add-E-e-为例讲解扩容" class="headerlink" title="add(E e)为例讲解扩容"></a>add(E e)为例讲解扩容</h3><ol><li>以<code>add(E e)</code>方法来看ArrayList时如何进行扩容的。首先看<code>add(E e)</code>源码，添加了注释。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    //确认当前当前size+1和容量对比，确认是否需要扩容。</span><br><span class="line">    ensureCapacityInternal(size + 1);</span><br><span class="line">    //因为数组下标是从0开始，最后将e对象放在elementData的size的位置。</span><br><span class="line">    //先运算后++，所以此段代码理解为elementData[size] = e; size++;</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算容量</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    //无参数的构造函数初始化elementData会为DEFAULTCAPACITY_EMPTY_ELEMENTDATA,所以这里会有此判断</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        //取DEFAULT_CAPACITY和minCapacity的最大值。</span><br><span class="line">        //所以如果是个空列表，第一次add操作会扩容为默认容量10</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    //计算出来需要的容量 &gt; 当前elementData容量会进行扩容</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Increases the capacity to ensure that it can hold at least the</span><br><span class="line"> * number of elements specified by the minimum capacity argument.</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity the desired minimum capacity</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    //oldCapacity原始容量</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    //newCapacity新扩充容量，即扩充后的容量 = oldCapacity + （oldCapacity*0.5）向下取整。例如容量为oldCapacity=10，newCapacity=10+5=15</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    //如果newCapacity扩容为原来的1.5倍还是比minCapacity小，则使用minCapacity的容量</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8, 需要分配的容量比MAX_ARRAY_SIZE还要大，会调用hugeCapacity方法分配容量</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    // 将老数组拷贝到新容量的数组中</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    //溢出了，抛错</span><br><span class="line">    if (minCapacity &lt; 0) // overflow</span><br><span class="line">        throw new OutOfMemoryError();</span><br><span class="line">    //没有达到MAX_ARRAY_SIZE则分配MAX_ARRAY_SIZE的容量，&gt; MAX_ARRAY_SIZE则分配Integer.MAX_VALUE容量</span><br><span class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;</span><br><span class="line">    return (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    //使用System.arraycopy方法复制，native方法速度快。</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h3><p>从源码看到一共有五种扩容逻辑。</p><ol><li><code>elementData</code> == <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>并且当前add的长度&lt;=10的时候，容量由0扩容为10</li><li>正常情况下新的容量为原来的1.5倍, 扩容后的<code>newCapacity &gt;= 原始容量+当前add添加的minCapacity</code>,新容量为<code>newCapacity = oldCapacity + (int)(oldCapacity*0.5)</code>。</li><li>扩容1.5倍之后的<code>newCapacity &lt; 原始容量+当前add添加的minCapacity</code>，新容量大小为<code>原始容量+当前add添加的minCapacity</code></li><li>计算出来的<code>newCapacity &gt; MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8)</code>, 原始容量 &lt; <code>MAX_ARRAY_SIZE</code>, 则新容量为<code>MAX_ARRAY_SIZE</code></li><li>计算出来的<code>newCapacity &gt; MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8)</code>, 原始容量 &gt;= <code>MAX_ARRAY_SIZE</code>, 则新容量为<code>Integer.MAX_VALUE</code></li></ol><h3 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h3><ol><li><p>我们来看下<code>MAX_ARRAY_SIZE</code>注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The maximum size of array to allocate.</span><br><span class="line"> * Some VMs reserve some header words in an array.</span><br><span class="line"> * Attempts to allocate larger arrays may result in</span><br><span class="line"> * OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line"> */</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br></pre></td></tr></table></figure></li><li><p>注释说的很明确，ArrayList在有些虚拟机上保留几个字节（8个字节），所以在这些虚拟机上最大容量是<code>Integer.MAX_VALUE-8</code>。正常情况下最大容量是<code>Integer.MAX_VALUE</code>。ArrayList中这段代码，小于0会报oom, 如果大于<code>MAX_ARRAY_SIZE</code>返回的是<code>Integer.MAX_VALUE</code>，但是在部分虚拟机上会报oom。</p></li></ol><h3 id="remove删除后容量变化"><a href="#remove删除后容量变化" class="headerlink" title="remove删除后容量变化"></a>remove删除后容量变化</h3><ol><li><p>remove删除某个下标的元素，该下标之后的元素通过<code>System.arraycopy</code>方法相当前移一位,但容量不会变化,也就是说删除不会进行缩容处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes the element at the specified position in this list.</span><br><span class="line"> * Shifts any subsequent elements to the left (subtracts one from their</span><br><span class="line"> * indices).</span><br><span class="line"> *</span><br><span class="line"> * @param index the index of the element to be removed</span><br><span class="line"> * @return the element that was removed from the list</span><br><span class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证删除前后容量不会变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;remove后容量&quot;)</span><br><span class="line">public void testAfterRemoveCapacity() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(10000);</span><br><span class="line">    Field field = ArrayList.class.getDeclaredField(&quot;elementData&quot;);</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    Object[] objs = (Object[]) field.get(list);</span><br><span class="line">    list.add(1);</span><br><span class="line">    System.out.println(&quot;before remove capacity=&quot; + objs.length);</span><br><span class="line">    System.out.println(&quot;before remove size=&quot; + list.size());</span><br><span class="line">    list.remove(0);</span><br><span class="line">    System.out.println(&quot;after remove capacity=&quot; + objs.length);</span><br><span class="line">    System.out.println(&quot;after remove size=&quot; + list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">before remove capacity=10000</span><br><span class="line">before remove size=1</span><br><span class="line">after remove capacity=10000</span><br><span class="line">after remove size=0</span><br></pre></td></tr></table></figure></li></ol><h2 id="ArrayList-遍历"><a href="#ArrayList-遍历" class="headerlink" title="ArrayList 遍历"></a>ArrayList 遍历</h2><h3 id="for遍历方式"><a href="#for遍历方式" class="headerlink" title="for遍历方式"></a>for遍历方式</h3><ol><li>先插入100条数据，然后使用for方式遍历，通过get方法获取对应下标存储的对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testArrayListTraverseByFor() &#123;</span><br><span class="line">    int size = 100;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        list.get(i);</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="foreach遍历方式"><a href="#foreach遍历方式" class="headerlink" title="foreach遍历方式"></a>foreach遍历方式</h3><ol><li>先插入100条数据，然后使用foreach方式遍历。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;foreach方式遍历&quot;)</span><br><span class="line">public void testArrayListTraverseByForeach() &#123;</span><br><span class="line">    int size = 100;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    for (Integer i : list) &#123;</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="迭代器遍历方式"><a href="#迭代器遍历方式" class="headerlink" title="迭代器遍历方式"></a>迭代器遍历方式</h3><ol><li>先插入100条数据，然后使用Iterator遍历,通过<code>hasNext()</code>方法判断是否结束，next方法获取当前值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;迭代器方式遍历&quot;)</span><br><span class="line">public void testArrayListTraverseByIterator() &#123;</span><br><span class="line">    int size = 100;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    for (Iterator&lt;Integer&gt; it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ol><li><p>首先我们创建容量为一千万的ArrayList，写入数据，通过三种方式遍历比较耗时情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;ArrayList遍历性能对比&quot;)</span><br><span class="line">public void testArrayListTraverse() &#123;</span><br><span class="line">    int size = 10000000;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        list.get(i);</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;for方式耗时 = &quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line">    for (Integer i : list) &#123;</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;foreach方式耗时 = &quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    for (Iterator i = list.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;迭代器方式耗时 = &quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果如下所示。通过对比看到耗时情况对比 for &lt; 迭代器Iterator &lt; foreach。所以对于ArrayList来说遍历性能排序，for &gt; 迭代器Iterator &gt; foreach。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for方式耗时 = 3</span><br><span class="line">foreach方式耗时 = 24</span><br><span class="line">迭代器方式耗时 = 4</span><br></pre></td></tr></table></figure></li></ol><h2 id="ArryList相关问题"><a href="#ArryList相关问题" class="headerlink" title="ArryList相关问题"></a>ArryList相关问题</h2><h3 id="ArrayList异常抛出常见场景"><a href="#ArrayList异常抛出常见场景" class="headerlink" title="ArrayList异常抛出常见场景"></a>ArrayList异常抛出常见场景</h3><ol><li>IllegalArgumentException</li></ol><ul><li>构造方法<code>ArrayList(int initialCapacity)</code> 初始化initialCapacity填写为负数，</li><li><code>subList(int fromIndex, int toIndex)</code>的fromIndex &gt; toIndex</li></ul><ol start="2"><li>NullPointerException</li></ol><ul><li>构造方法<code>ArrayList(Collection&lt;? extends E&gt; c)</code> collection传入为null</li><li><code>addAll(Collection&lt;? extends E&gt; c)</code> collection传入为null</li><li><code>addAll(int index, Collection&lt;? extends E&gt; c)</code> collection传入为null</li></ul><ol start="3"><li>IndexOutOfBoundsException</li></ol><ul><li><code>get(int index)</code> index下标越界</li><li><code>set(int index, E element)</code> index下标越界</li><li><code>add(int index, E element)</code> index下标越界</li><li><code>remove(int index)</code> index下标越界</li><li><code>addAll(int index, Collection&lt;? extends E&gt; c)</code> index下标越界</li><li><code>removeRange(int fromIndex, int toIndex)</code> 下标越界</li><li><code>subList(int fromIndex, int toIndex)</code> 下标越界</li></ul><ol start="4"><li>NoSuchElementException</li></ol><ul><li>迭代器next或者previous操作越界</li></ul><ol start="5"><li>ConcurrentModificationException</li></ol><ul><li>多线程同时操作添加或删除操作</li></ul><ol start="6"><li>IllegalStateException</li></ol><ul><li>迭代器设置、删除操作未先next操作的情况</li></ul><h3 id="ArrayList安全的remove操作"><a href="#ArrayList安全的remove操作" class="headerlink" title="ArrayList安全的remove操作"></a>ArrayList安全的remove操作</h3><ol><li><p>for循环里删除，使用外部定义的size会抛<code>IndexOutOfBoundsException</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testRemoveException() &#123;</span><br><span class="line">    int size = 10;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">java.lang.IndexOutOfBoundsException: Index: 5, Size: 5</span><br></pre></td></tr></table></figure></li><li><p>for循环里删除，使用ArrayList的size，可见size时一直在变化的。最终数据并没有删除完，还剩下一半的数据。如果想删除完可以将<code>list.remove(i);</code>替换为<code>list.remove(0);</code>，数组中的数据一直在变，下标也在变动。想匹配删除某个元素也比较麻烦，所以这种删除应用起来也比较鸡肋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testRemoveByForArraListSize() &#123;</span><br><span class="line">    int size = 10;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">        System.out.println(&quot;size=&quot; + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;end size=&quot; + list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">size=9</span><br><span class="line">size=8</span><br><span class="line">size=7</span><br><span class="line">size=6</span><br><span class="line">size=5</span><br><span class="line">end size=5</span><br></pre></td></tr></table></figure></li><li><p>使用迭代器，边遍历边删除元素。可以在<code>it.remove();</code>前做逻辑判断等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testRemoveByIterator() &#123;</span><br><span class="line">    int size = 10;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(size);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Iterator it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        //TODO if</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;end size=&quot; + list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">end size=0</span><br></pre></td></tr></table></figure></li></ol><h3 id="ArrayList是非线程安全"><a href="#ArrayList是非线程安全" class="headerlink" title="ArrayList是非线程安全"></a>ArrayList是非线程安全</h3><ol><li>如果第一个线程在删除，第二个线程在添加，第三个线程在读取。ArrayList的size会变化，具体变成多少是不确定的，所以很容易出现<code>IndexOutOfBoundsException</code>。</li><li>避免方式</li></ol><ul><li>采用单线程处理业务员。</li><li>使用<code>CopyOnWriteArrayList</code>。</li><li>对ArrayList的操作全部加锁，synchronized或者Lock。</li><li>在初始化时用<code>Collections.synchronizedList</code>方法进行包装。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayList的列表对象实质上是存储在一个引用型数组里的。&lt;br&gt;源码基于jdk1.8版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://qiubyte.github.io/categories/Java/"/>
    
    
      <category term="List" scheme="https://qiubyte.github.io/tags/List/"/>
    
      <category term="ArrayList" scheme="https://qiubyte.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>mysql8.0 授权远程登录连接</title>
    <link href="https://qiubyte.github.io/2019/10/09/2019/20191009-mysql8.0%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%BF%9E%E6%8E%A5/"/>
    <id>https://qiubyte.github.io/2019/10/09/2019/20191009-mysql8.0授权远程登录连接/</id>
    <published>2019-10-09T12:00:00.000Z</published>
    <updated>2022-12-30T02:12:00.716Z</updated>
    
    <content type="html"><![CDATA[<p>mysql8不可以root用户直接授权，需要新建用户。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用docker安装mysql8，需求开启远程登录连接，但使用grant操作一直报错。之前使用5.7版本的时候是没有问题的，所以认为应该是版本问题导致的，MySQL8应该修改了赋予权限的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos;;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;IDENTIFIED BY &apos;root&apos;&apos; at line 1</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>新版本将创建账户和赋予权限的方式分开，mysql8不可以root用户直接授权，需要新建用户。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>创建dev用户(以dev用户为例)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 新建dev用户</span><br><span class="line">mysql&gt;  create user &apos;dev&apos;@&apos;%&apos; identified with mysql_native_password by &apos;dev&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>MySQL8和5的密码加密方式不同，mysql_native_password是5的加密方式。mysql已经将之前的mysql_native_password认证，修改成了caching_sha2_password认证方式。所以，使用类似于navicat或是sqlyog这些客户端时，默认使用还是mysql_native_password认证方式，所以即使输入正确的用户和密码依然登录不成功。客户端新版未测试过，不清楚是否已经支持</p></blockquote><ol start="2"><li><p>查看下表里是否有dev用户，host是否为<code>%</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看mysql库user表</span><br><span class="line">mysql&gt; select user,host from user;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| dev              | %         |</span><br><span class="line">| healthchecker    | localhost |</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| root             | localhost |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>赋予权限, (修改权限时在后面加with grant option)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等。</span><br><span class="line">mysql&gt; grant all on *.* to &apos;dev&apos;@&apos;%&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br></pre></td></tr></table></figure></li><li><p>刷新权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 刷新权限</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure></li><li><p>再次使用Navicat测试,连接成功！</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql8不可以root用户直接授权，需要新建用户。&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="https://qiubyte.github.io/categories/software/"/>
    
      <category term="mysql" scheme="https://qiubyte.github.io/categories/software/mysql/"/>
    
    
      <category term="mysql" scheme="https://qiubyte.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat too many open files</title>
    <link href="https://qiubyte.github.io/2019/09/29/2019/20190929-Tomcat%20too%20many%20open%20files/"/>
    <id>https://qiubyte.github.io/2019/09/29/2019/20190929-Tomcat too many open files/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2022-12-30T02:12:00.716Z</updated>
    
    <content type="html"><![CDATA[<p>tomcat运行一段时间之后出现文件句柄数过多的情况,<br><code>java.net.SocketException: Too many open files</code></p><a id="more"></a><h2 id="网上解决方法"><a href="#网上解决方法" class="headerlink" title="网上解决方法"></a>网上解决方法</h2><p>A couple of days ago we ran into the infamous “too many open files” when our Tomcat web server was under load. </p><p>There are several blogs around the internet that tries to deal with this issue but none of them seemed to do the trick for us. Usually what you do is to set the ulimit to a greater value (it’s something like 1024 by default). But in order to make it permanent after reboot the first thing suggested is to update the /proc/sys/fs/file-max file and increase the value then edit the /etc/security/limits.conf and add the following line * - nofile 2048 (see here for more details). But none of this worked for us. We saw that when doing</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;tomcat pid&gt;/limits</span><br></pre></td></tr></table></figure><p>the limit was still set to the initial value of 1024:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        0                    unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             63810                63810                processes</span><br><span class="line">&lt;b&gt;Max open files                1024                     1024                    files&lt;/b&gt;</span><br><span class="line">Max locked memory         65536                65536                bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       63810                63810                signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure><p>It was not until we found this thread that the reason and solution became clear. Our Tomcat instance was started as a service during boot and there’s a bug discovered and filed (with patch) in 2005 that doesn’t seem to have been resolved yet. The bug reveals itself by ignoring the max number of open files limit when starting daemons in Ubuntu/Debain. So the work-around suggested by “BOK” was to edit /etc/init.d/tomcat and add:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn 16384</span><br><span class="line">ulimit -Sn 16384</span><br></pre></td></tr></table></figure><p>Finally the max number of open files for Tomcat was increased!</p><p>以上摘自：<a href="https://blog.jayway.com/2012/02/11/how-to-really-fix-the-too-many-open-files-problem-for-tomcat-in-ubuntu/" target="_blank" rel="noopener">https://blog.jayway.com/2012/02/11/how-to-really-fix-the-too-many-open-files-problem-for-tomcat-in-ubuntu/</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li><p>打开的文件过多，一般来说是由于应用程序对资源使用不当造成，比如没有及时关闭Socket或数据库连接等。但也可能应用确实需要打开比较多的文件句柄，而系统本身的设置限制了这一数量。</p></li><li><p>Tomcat将主动打开尽可能多的文件句柄，并将硬限制设置为如此高的数量将导致有问题的虚拟机可以消耗大量内存。</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看系统允许打开的最大文件数</span><br><span class="line">cat /proc/sys/fs/file-max</span><br><span class="line"></span><br><span class="line">tomcat文件句柄数</span><br><span class="line">cat /proc/&lt;tomcat pid&gt;/limits</span><br></pre></td></tr></table></figure></li><li><p>不仅要关注系统最大文件句柄数，还要关注tomcat启动能使用的最大句柄数。</p></li><li><p>在I/O操作之后需要在finally里调用close()。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tomcat运行一段时间之后出现文件句柄数过多的情况,&lt;br&gt;&lt;code&gt;java.net.SocketException: Too many open files&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="https://qiubyte.github.io/categories/software/"/>
    
      <category term="tomcat" scheme="https://qiubyte.github.io/categories/software/tomcat/"/>
    
    
      <category term="tomcat" scheme="https://qiubyte.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot RestTemplate 忽略https证书</title>
    <link href="https://qiubyte.github.io/2018/01/11/2019/20180111-SpringBoot-RestTemplate%20%E5%BF%BD%E7%95%A5https%E8%AF%81%E4%B9%A6/"/>
    <id>https://qiubyte.github.io/2018/01/11/2019/20180111-SpringBoot-RestTemplate 忽略https证书/</id>
    <published>2018-01-11T12:00:00.000Z</published>
    <updated>2022-12-30T02:12:00.716Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot RestTemplate 忽略https证书的方法</p><a id="more"></a><h2 id="忽略Https证书方法"><a href="#忽略Https证书方法" class="headerlink" title="忽略Https证书方法"></a>忽略Https证书方法</h2><p>话不多说直接上代码.</p><ol><li><p>添加Http忽略证书代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class HttpClientFactory &#123;</span><br><span class="line"> </span><br><span class="line">   private static final int readTimeout = 5000;</span><br><span class="line">   private static final int connectTimeout = 5000;</span><br><span class="line"> </span><br><span class="line">   public static CloseableHttpClient acceptsUntrustedCertsHttpClient() throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException &#123;</span><br><span class="line">      SSLConnectionSocketFactory sslsf = null;</span><br><span class="line">      //忽略ssl证书</span><br><span class="line">      try &#123;</span><br><span class="line">         SSLContext sslContext = org.apache.http.conn.ssl.SSLContexts.custom().useTLS().loadTrustMaterial(null, new TrustSelfSignedStrategy() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">               return true;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;).build();</span><br><span class="line">         sslsf = new SSLConnectionSocketFactory(sslContext, new String[]&#123;&quot;TLSv1.2&quot;&#125;, null,</span><br><span class="line">               SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      RequestConfig defaultRequestConfig = RequestConfig.custom().setSocketTimeout(readTimeout)</span><br><span class="line">            .setConnectTimeout(connectTimeout).setStaleConnectionCheckEnabled(true).build();</span><br><span class="line"> </span><br><span class="line">      return HttpClients.custom().setSSLSocketFactory(sslsf).setDefaultRequestConfig(defaultRequestConfig).build();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RestTemplate bean初始代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">RestTemplate restTemplate() throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException &#123;</span><br><span class="line">   CloseableHttpClient httpClient = HttpClientFactory.acceptsUntrustedCertsHttpClient();</span><br><span class="line">   HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line"> </span><br><span class="line">   RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory);</span><br><span class="line">   restTemplate.setErrorHandler(new ResponseErrorHandler());</span><br><span class="line">   return restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot RestTemplate 忽略https证书的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java框架" scheme="https://qiubyte.github.io/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/categories/Java%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    
    
      <category term="Java" scheme="https://qiubyte.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://qiubyte.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
